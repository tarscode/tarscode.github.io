<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MyBatis逆向工程]]></title>
    <url>%2F2017%2F07%2F08%2FMyBatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简介MyBatis是一款ORM框架，可以将实体类和数据库中的表进行一一映射，那么也可以支持通过数据库表生成实体类。下面介绍MyBatis和Idea实现MyBatis的逆向工程。 步骤一、创建一个Maven项目，并在pom.xml文件中添加MyBatis Generator插件的配置文件 &lt;build&gt; &lt;finalName&gt;mybatis_generator&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 二、在resource目录下创建yBatis Generator的配置文件generatorConfig.xml（官方的配置说明：http://mybatis.github.io/generator/configreference/xmlconfig.html） &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!--导入属性配置--&gt; &lt;properties resource="jdbc.properties"&gt;&lt;/properties&gt; &lt;!--指定特定数据库的jdbc驱动jar包的位置 &lt;classPathEntry location="$&#123;jdbc.driverLocation&#125;"/&gt; --&gt; &lt;context id="default" targetRuntime="MyBatis3"&gt; &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--jdbc的数据库连接 --&gt; &lt;jdbcConnection driverClass="$&#123;jdbc.driverClassName&#125;" connectionURL="$&#123;jdbc.url&#125;" userId="$&#123;jdbc.username&#125;" password="$&#123;jdbc.password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类 targetPackage 指定生成的model生成所在的包名 targetProject 指定在该项目下所在的路径 --&gt; &lt;javaModelGenerator targetPackage="com.tarsbatis.beans" targetProject="src/main/java"&gt; &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;!-- 是否对model添加 构造函数 --&gt; &lt;property name="constructorBased" value="true"/&gt; &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;!-- 建立的Model对象是否 不可改变 即生成的Model对象不会有 setter方法，只有构造方法 --&gt; &lt;property name="immutable" value="false"/&gt; &lt;/javaModelGenerator&gt; &lt;!--Mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt; &lt;sqlMapGenerator targetPackage="com.tarsbatis.dao.mapper" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码 type="ANNOTATEDMAPPER",生成Java Model 和基于注解的Mapper对象 type="MIXEDMAPPER",生成基于注解的Java Model 和相应的Mapper对象 type="XMLMAPPER",生成SQLMap XML文件和独立的Mapper接口 --&gt; &lt;javaClientGenerator targetPackage="com.tarsbatis.dao" targetProject="src/main/java" type="XMLMAPPER"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;table tableName="seckill" domainObjectName="Seckill" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 三、配置Maven构建，点击Run-Edit Configurations，然后添加Maven配置 四、点击Run运行，就可以生成相应的文件 参考资料http://www.mybatis.org/generator/index.html http://www.mybatis.org/generator/configreference/xmlconfig.html https://my.oschina.net/lujianing/blog/200135]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Java并发编程的艺术》读书笔记]]></title>
    <url>%2F2017%2F05%2F25%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[书名：《Java并发编程的艺术》作者：方腾飞 并发编程的挑战减少上下文切换的方法 无锁并发编程：例如将数据的ID按照Hash算法分段取模 CAS算法：Java的Atomic包使用CAS算法更新数据，而不需要加锁 使用最少的线程：避免创建不需要的线程 协程：在单线程里实现多任务的切换，并在单线程里维持多个任务间的切换 避免死锁的几个常见方法 避免一个线程同时获取多个锁 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源 避免使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况 Java并发机制的底层实现原理锁一共分为四种状态：级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。 Java内存模型Java内存模型基础Java内存模型的抽象结构Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java编程时所说的变量不一样，指包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。 Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存线程的工作内存保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作(读取、赋值)都必须在工作内存进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程变量值的传递均需要在主内存来完成。 如上图所示，如果线程A与线程B之间要通信的话，必须要经历下面2个步骤： 线程A把本地内存A中更新过的共享变量刷新到主内存中去 线程B到主内存中去读取线程A之前更新过的共享变量 从源代码到指令序列的重排序在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。 编译器优化的重排序 指令级并行的重排序 内存系统的冲排序 内存屏障为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来进制特定类型的处理器重排序，JMM吧内存屏障指令分为4类， happens-before简介在JMM中，如果一个操作执行的结果需要对另外一个操作可见，那么这两个操作之间必须要存在happens-before关系。 与程序员密切相关的happens-before规则如下： 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后序操作 监视器规则：对一个锁的解锁，happens-before于随后对这个锁的加锁 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读 传递性：如果A happens-before B,且B happens-before C，那么A happens-before C Java中的锁Lock接口提供的synchronized关键所不具备的主要特性 尝试非阻塞地获取锁：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁 能中断地获取锁：与synchronized不同，获取锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放 超时获取锁：在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回 Java并发容器和框架ConcurrentHashMap的实现原理和使用ConcurrentHashMap采用锁分段技术，首先将数据分成一段一段地存储，然后给每一部分数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁(ReentrantLock),在ConcurrentHashMap中扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里面包含一个HashEntry数组，每个HashEntry是一个链表结构结构的元素，每个Segment守护者一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时必须首先获得与它队形的Segment锁。 定位Segment，采用Wang/Jenkins hash的变种算法对元素的hashcode进行一次再散列。 ConcurrentHashMap的操作get操作 get操作的高效之处在于整个get过程不需要加锁，除非读到的值为空时才会加锁重读。原理是将get方法里面的使用的共享变量都定义成volatile类型，如用于统计当前Segment大小的count字段和用于存储值的HashEntry的value。 ConcurrentLinkedQueueJava里的阻塞队列 ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列 LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列 PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列 DelayQueue：一个使用优先级队列实现的无界阻塞队列 SynchronousQueue：一个不存储元素的阻塞队列 LinkedTransferQueue：一个由链表结构组成的无界阻塞队列 LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列 Java中的并发工具类 Java中的线程池Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。开发过程中使用线程池能够带来3个好处： 提高资源消耗。通过重复利用已经创建的线程减低线程创建和销毁造成的消耗 提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行 提高线程的可管理性。线程是稀缺资源，如果无限制的串讲，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。 线程池的实现原理当向线程池提交一个任务后，线程池是如何处理这个任务的呢？如图所示。 处理流程； 核心线程池-&gt;工作队列-&gt;线程池-&gt;饱和策略处理 ThreadPoolExecutor执行executor()方法的示意图如上图所示，分为下列4种情况： 如果当前运行的线程少于corePoolSize,则创建新线程来执行任务(注意，执行这一步骤需要获取全局锁) 如果运行的线程等于或者多余corePoolSize,则将任务加入BlockingQueue。 如果无法将任务加入BlockingQueue(队列已满)，则创建新的线程来处理任务(注意，执行这一步骤需要获取全局锁)。 如果创建新线程将使当前运行的线程超出maximumPoolSize,任务将被拒绝，并调用RejectedExecuteHandler.rejectExecution()方法。 ThreadPoolExecutor采用上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免全局锁(那将会是一个严重的可伸缩瓶颈)。在ThreadPoolExecutor完成预热之后(当前运行的线程数目大于等于corePoolSize),几乎所有的excute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。 线程池的使用线程池的创建通过ThreadPoolExecutor创建一个线程池 new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds, runnableTaskQueue, handler); runnableTaskQueue(任务队列)：用于保存等待执行的任务的阻塞队列，有4种： ArrayBlockingQueue:是一个基于数组结构的有界队列，按FIFO对元素进行排序 LinkedBlockingQueue:是一个基于链表结构的阻塞队列，按FIFO对元素进行排序，吞吐量高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列 SynchronousQueue:是一个不才能出元素的阻塞队列，每个插入操作必须等到另一个线程调用溢出操作，否则插入操作一直处于阻塞状态，吞吐量通常高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列 PriorityBlockingQueue:一个具有优先级的无限阻塞队列 RejectedExecutionHandler(饱和策略):当队列和线程池都满了,说明线程池处于饱和状态,那么必须采取一种策略处理提交的新任务。这个策略默认是AbortPolicy，表示无法处理时抛出异常。共包括4种策略： AbortPolicy:直接抛出异常 CallerRunsPolicy:只用调用者所在线程来运行任务 DiscardOldestPolicy:丢弃队列里最近的一个任务，并执行当前任务 DiscardPolicy:不处理丢弃掉 向线程池提交任务可以使用两种方法向线程池提交任务： execute():用于提交不需要返回值的任务 submit():用于提交需要返回值的任务 关闭线程池可以调用线程池的shutdown或shutdownNow方法来关闭线程池。原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是二者有一定的区别： shutdownNow首先将线程池的状态设置成STOP,然后尝试停止所有的正在执行或者暂停任务的线程，并返回等待执行任务的列表 shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程 合理地配置线程池任务的性质：CPU密集型任务、IO密集型任务和混合型任务 任务的优先级：高、中和低 任务的执行时间：长、中和短 任务的依赖性：是否依赖其他系统资源，如数据库连接 例子： CPU密集型任务应该配置尽可能小的线程，如配置Ncpu+1个线程的线程池 IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务。可以通过Runtime.getRuntime().availableProceesors()方法获得当前设备的CPU个数 优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理，它可以让优先级高的任务先执行 Executor框架在Java中使用线程来异步执行任务，Java的线程既是工作单元，也是执行机制。工作单元包括Runnable和Callable，而执行机制由Executor框架提供。 Executor框架简介Executor框架主要由3大部分组成： 任务。包括被执行任务需要执行的接口：Runnable和Callable 任务的执行。包括任务执行机制的核心接口Executor,以及集成子Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口(ThreadPoolExecutor和ScheduledThreadPoolExecutor) 异步计算的结果。包括接口Future和实现Future接口和FutureTask类。 Executor框架的主要成员： ThreadPoolExecutor ScheduledThreadPoolExecutor Future接口 Runnable接口 Callable接口 Executors (1) ThreadPoolExecutor ThreadPoolExecutor通常通过工厂类Executors来创建,Executors可以创建3种类型的ThreadPoolExecutor： SingleThreadExecutor:单个线程，适用于需要保证顺序地执行各个任务;并且在任意时间点，不会有多个线程是活动的场景 FixedThreadPool:固定线程数目，限制当前线程数量的应用场景，适用负载比较重的服务器 CacheThreadPool:大小无界的线程池，适用于执行很多短期异步任务的小程序，或者负载较轻的服务器，创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 (2) ScheduledThreadPoolExecutor ScheduledThreadPoolExecutor通常通过工厂类Executors来创建,Executors可以创建2种类型的ScheduledThreadPoolExecutor，如下： ScheduledThreadPoolExecutor：包括若干线程，适合需要多个后台线程执行周期任务，同时为了满足资源管理的需求需要限制后台线程的数量的应用场景 SingleThreadPoolExecutor：只包括一个线程，适合需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景 (3) Future接口 Future接口和实现Future接口的FutureTask类用来表示异步计算的结果。当我们把Runnable接口或Callable接口的实现类提交(submit)给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，ThreadPoolExecutor或ScheduledThreadPoolExecutor会向我们返回一个FutureTask对象。 (4) Runnable接口和Callable接口 Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。区别是Runnable不会返回结果，而Callable可以返回结果。 ThreadPoolExecutor详解Executor框架最核心的类是ThreadPoolExecutor，它是线程的实现类，主要由4个构件组成： corePool：核心线程池的大小 maximumPool：最大线程池的大小 BlockingQueue：用来暂时保存任务的工作队列 RejectedExecutionHandler：当ThreadPoolExecutor已经关闭或者ThreadPoolExecutor已经饱和时(达到了最大线程池大小且工作队列已满)，execute()方法将要调用的Handler FutureTask详解Future接口和实现Future接口的FutureTask类，代表异步计算的结果 FutureTask除了实现了Future接口外，还实现了Runnable接口。因此FutureTask可以交给Executor执行，也可以有调用线程直接执行(FutureTask.run())。 FutureTask的实现 FutureTask的实现基于AbstractQueueSynchronizer(简称为AQS),java.util。concurrent中的很多可阻塞类都是基于AQS实现的。AQS是一个同步框架,它提供通用机制来原子性管理同步状态、阻塞状态和唤醒线程，以及维护被阻塞线程的队列。基于AQS的同步器包括：ReentrantLock、Semaphore、ReenrantReadWriteLock 、CountDownLatch和FutureTask。 每一个基于AQS实现的同步器都会包含两种类型的操作，如下： 至少一个acquire操作，这个操作阻塞调用线程，除非/直到AQS的状态允许这个线程继续执行。FutureTask的acquire操作为get()/get(long timeout,TimeUnit unit)方法调用 至少一个release操作，这个操作改变AQS的状态，改变后的状态可允许一个或多个阻塞线程被解除阻塞。FutureTask的release操作包括run()方法和和cancel()方法]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理详解]]></title>
    <url>%2F2017%2F05%2F23%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[简介在某些情况下，我们不希望或是不能直接访问对象 A，而是通过访问一个中介对象 B，由 B 去访问 A 达成目的，这种方式我们就称为代理。 这里对象 A 所属类我们称为委托类，也称为被代理类，对象 B 所属类称为代理类。 代理优点有： 隐藏委托类的实现 解耦，不改变委托类代码情况下做一些额外处理，比如添加初始判断及其他公共操作 根据程序运行前代理类是否已经存在，可以将代理分为静态代理和动态代理。动态代理实现方式主要有两种，分别是JDK动态代理和CGlib动态代理。二者的主要区别是JDK动态代理是通过反射，只能代理实现接口的目标类，而CGlib是通过继承目标类，因而不能代理final类。 代理类在程序运行前不存在、运行时由程序动态生成的代理方式称为动态代理。 Java 提供了动态代理的实现方式，可以在运行时刻动态生成代理类。这种代理方式的一大好处是可以方便对代理类的函数做统一或特殊处理，如记录所有函数执行时间、所有函数执行前添加验证判断、对某个特殊函数进行特殊操作，而不用像静态代理方式那样需要修改每个函数。 代理模式原理代理模式就是给某一个对象创建了一个代理对象，由这个代理对象控制原对象的引用，而创建这个代理对象后可以在调用原对象时增加一些额外的操作。如下图所示是代理模式的结构。 接口：它是代理对象的真实对象要实现的接口 代理类：除了实现上述的接口外，还需要持有代理对象的引用 实现类：被代理的类，是目标对象 创建代理对象的时序图如下所示 动态代理实现JDK实现动态代理包括三步： 新建委托类； 实现InvocationHandler接口，这是负责连接代理类和委托类的中间类必须实现的接口； 通过Proxy类新建代理类对象。 接口 public interface Greeting &#123; void sayHello(String name);&#125; 目标类 public class GreetingImpl implements Greeting &#123; public void sayHello(String name) &#123; System.out.println("say Hello:"+name); &#125;&#125; JDK代理类 InvocationHandler接口，前者Invocation为执行，后者Handler为句柄（实际对象的间接引用）。对于invoke函数，调用代理对象的所有方法都会调用这个函数。 public class JDKDynamicProxy implements InvocationHandler &#123; private Object target; public JDKDynamicProxy(Object target)&#123; this.target = target; &#125; public &lt;T&gt; T getPoxy()&#123; return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this ); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); Object result = method.invoke(target,args); after(); return result; &#125; public void before()&#123; System.out.println("before"); &#125; public void after()&#123; System.out.println("after"); &#125;&#125; cglib代理类 public class CGLibDynamicProxy implements MethodInterceptor &#123; private static CGLibDynamicProxy instance = new CGLibDynamicProxy(); private CGLibDynamicProxy()&#123; &#125; public static CGLibDynamicProxy getInstance()&#123; return instance; &#125; public &lt;T&gt; T getProxy(Class&lt;T&gt; cls)&#123; return (T) Enhancer.create(cls,this); &#125; @Override public Object intercept(Object target, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; before(); Object result = proxy.invokeSuper(target,args); after(); return result; &#125; public void before()&#123; System.out.println("before"); &#125; public void after()&#123; System.out.println("after"); &#125;&#125; 测试 public class Client &#123; public static void main(String[] args) &#123; //JDK动态代理 Greeting greeting = new JDKDynamicProxy(new GreetingImpl()).getPoxy(); greeting.sayHello("Jack"); //CGLib动态代理 Greeting greeting2 = CGLibDynamicProxy.getInstance().getProxy(GreetingImpl.class); greeting2.sayHello("Rose"); &#125;&#125; 结果 beforesay Hello:Jackafterbeforesay Hello:Roseafter 参考资料 《架构探险》 《深入分析Java Web技术内幕》]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LRU算法原理与实践]]></title>
    <url>%2F2017%2F04%2F23%2FLRU%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[简介操作系统中进行内存管理中时采用一些页面置换算法，如LRU、LFU和FIFO等。其中LRU应用较为广泛。LRU的全称是Least Recently Used，即最近最少使用算法。 大家都知道在缓存的大小是有限的，那么我们应该基于什么策略进行缓存数据呢？LRU提供的思路是将最近没有使用的数据从缓存中移除，这样的思路在实际的环境中比较符合常识。 原理LRU算法的原理比较简单，数据存储的数据结构为链表。当访问数据时，如缓存中有数据，则将该数据移动至链表的顶端；没有该数据则在顶端加入该数据，并移除链表中的低端的数据。 LRU涉及一个概念叫做缺页中断，缺页中断的次数即一次访问过程时没有没有在缓存中找到数据。 假如页面大小为3，序列为4、3、2、3、5，下面的缺页次数为4次 4 3 2 3 5 4 3 2 3 5 null 4 3 2 3 null null 4 4 2 缺页 缺页 缺页 不缺 缺页 代码实现LRU算法原理较为简单，但是实现较为复杂，尤其是处理页面替换时，在Java中的LinkedHashMap的访问有序性恰好满足LRU的需求。下面通过LeetCode第146题描述下算法的实现过程 样例： 实现如下操作，且时间复杂度为O(1) LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 代码实现 public class LRUCache &#123; private LinkedHashMap&lt;Integer, Integer&gt; map; private final int CAPACITY; public LRUCache(int capacity) &#123; CAPACITY = capacity; map = new LinkedHashMap&lt;Integer, Integer&gt;(capacity, 0.75f, true)&#123; protected boolean removeEldestEntry(Map.Entry eldest) &#123; return size() &gt; CAPACITY; &#125; &#125;; &#125; public int get(int key) &#123; return map.getOrDefault(key, -1); &#125; public void put(int key, int value) &#123; map.put(key, value); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书记录]]></title>
    <url>%2F2017%2F03%2F18%2F%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[最近又屯了好几本书，作为京东的图书Lv4会员，看看自己的藏书单差不多有近百本书，但是实际上却有好多没有怎么看，甚至有的连包装都没有拆开。决定写一下自己的阅读记录，督促下自己多读一些好书。 在读 《Spring源码深度解析》 《分布式Java基础与实践》 已读技术 《Java核心技术卷1》 《Java核心技术卷2》 《Java编程思想》 《Java并发编程的艺术》 《Java多线程编程核心技术》 《Spring实战》 《Spring Boot实战》 《Spring Boot揭秘》 《图解HTTP》 《图解TCP/IP》 《TCP/IP详解卷1》 《大型网站技术架构核心原理与案例分析》 《大型分布式网站架构设计与实践》 《大型网站系统与Java中间件》 《深入分析Java Web技术内幕》 《鸟哥的Linux私房菜》 《Ruby基础教程》 《Python基础教程》 《剑指Offer》 《架构探险》 非技术 《黑客与画家》 《黑客简史》 《淘宝技术这十年》 《京东技术解密》 《淘宝十年产品事》 《浪潮之巅》 《数学之美》 《技巧》 《Mactalk人生元编程》 《Mactalk跨越边界》 未读完 《深入理解Java虚拟机》 《算法》 《Spring技术内幕》 《高性能MySQL》 《深入浅出MyBatis技术原理与实战》 《Maven实战》 《Redis实战》 《Java并发编程实践》 未读 《深入理解计算机系统》 《现代操作系统》 《Head Firet设计模式》 《高可用MySQL》 《分布式服务框架原理与实践》 《Java RESTful Web Service实战》 《Redis设计与实现》 未完待续，整理简短的读书心得。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Spring Boot实战》读书笔记]]></title>
    <url>%2F2017%2F03%2F11%2FSpringBoot%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[《Spring Boot实战》这本书虽然题目是Spring Boot，但是有一半的内容讲的是Spring，虽然有点偏题之嫌，但是书中讲的Spring还是非常有条理的，让人看着清晰明了。 Spring基础IOCSpring管理的对象称为beans。 控制反转IoC(Inversioin Of Control)和依赖注入DI(Dependency Injection)的区别：IoC有两种方式一种是DI,另外一种是DL,即Dependency Lookup( 依赖查找)。 Spring IoC容器的依赖注入流程： 收集和注册：定义bean 分析和组装：查找依赖 Spring Boot通过提供众多起步依赖降低项目依赖的复杂度。起步依赖本质上是一个Maven项目对象模型(Project Object Model,POM)定义了对其他库的传递依赖。 Spring使用简单的POJO(Plain Old Java Object,无任何限制的普通对象)来进行企业级开发。每一个被Spring管理的Java对象都称之为Bean；而Spring提供了一个IoC容器用来初始化对象，解决对象间的依赖管理和对象的使用。 Spring框架本身有四大原则： 使用POJO进行轻量级和最小侵入式开发； 通过依赖注入和基于接口编程实现松耦合； 通过AOP和默认习惯进行声明式编程 使用AOP和模板(template)减少模块代码 Spring IoC容器(ApplicationContext)负责创建Bean，并通过容器将类Bean注入到你需要的Bean中。Spring提供使用xml、注解、Java配置、groovy配置实现Bean的创建和注入。其中Java配置是通过@Configuration和@Bean来实现的。 声明Bean的注解： @Component组件，没有明确的角色 @Service在业务逻辑层(service层)使用 @Repository在数据访问层(dao层)使用 @Controller在展现层(MVC->Spring MVC)使用 注入Bean的注解，一般情况下通用，下面三个注解可注解在set方法上或者属性上： @Autowired：Spring提供的注释 @Inject：JSR-330提供的注解 @Resource：JSR-250提供的注解 其他注解： @Configuration声明当前类是一个配置类，相当于一个Spring配置的xml文件 @ComponentScan自动扫描包名下所有使用@Service、@Component、@Repository和@Controller的类，并注册为Bean Bean注解在方法上，声明当前方法的返回值是一个Bean AOPAOP：面向切面编程，相对于OOP面向对象编程。 Spring的AOP存在的目的在于解耦，AOP可以让一组类共享相同的行为。在OOP中之只能通过集成类和实现接口，来使代码的耦合度增强，且类继承之恩给你为单继承，阻碍更多行为添加到一组类上。 Spring支持注解式面向切面编程 使用@Aspect声明是一个切面 使用@After、@Before、@Around定义建言(advice)，可以直接将拦截规则(切点)作为参数 其中@After、@Before、@Around参数的拦截规则为切点(PointCut)，为了使切点复用，可使用@PointCut撰文定义拦截规则,然后在@After、@Before、@Around的参数中调用 其中符合条件的每一个被拦截处为连接点(JoinPoint) Spring常用配置Bean的ScopeScope是范围的意思,描述的是Spring容器如何新建Bean的实例的。Spring的Scope有以下几种，通过@Scope注解实现。 Singleton：一个Spring容器只有一个Bean的实例，是Spring的默认配置，全容器共享一个实例。 Prototype：每次调用新建一个Bean的实例。 Request：Web项目中，给每一http request新建一个Bean实例 Session：Web项目中，给每一个http session新建一个Bean实例 GlobalSession：这个只在portal应用中有用，给每一个global http session新建一个Bean实例 ProfileProfile为不同环境下使用不同的配置提供了支持(开发环境下的配置和生成环境下的配置肯定是不同的，例如数据库的配置。 事件(Application Event)Spring的事件(Application Event)为Bean与Bean之间的消息通信提供了支持。当一个Bean处理完了一个任务之后，希望另外一个Bean知道并能做相应的处理，这时我们就需要让另外一个Bean监听当前Bean所发送的事件。 Spring的事件遵循如下流程： 自定义事件，继承ApplicationEvent 定义事件监听器，实现ApplicationListener 使用容器发布事件 Spring高级话题Spring AwareSpring Aware的目的是为了让Bean获得Spring容器的服务。 第4章 Spring MVC基础Spring MVC常用注解 @RestController：是一个组合注解，组合了@Controller和@ResponseBody Spring MVC基本配置拦截器(Interceptor)实现对每一个请求处理前后进行相关的业务处理，类似于Servlet的Filter。 通过@ControllerAdvice可以将控制的全局配置放在同一配置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上，这对所有注解了@RequestMapping的控制器内的方法有效。 @ExceptionHandler：用于全局处理控制器里的异常 @InitBinder：用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求到Model中。 @ModelAttribute：本来的作用是绑定键值对到Model里，此处的让全局的@RequestMapping都能获取此处设置的键值对。 Spring Boot基础Spring Boot的优点： 快速构建项目 对主流开发框架的无配置集成 项目可独立运行，无须外部依赖Servlet容器 提供运行时的应用监控 极大地提高了开发、部署效率 与云计算天然集成]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SingleNumber系列问题]]></title>
    <url>%2F2017%2F03%2F06%2FSingleNumber%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[单个数字问题解法多种多样,主要应用了位运算，非常有趣。 Single Number题目内容Given an array of integers, every element appears twice except for one. Find that single one. 题目大意：给定一个数组,其中所有元素出现了两次,有一个元素出现了一次,找出这个元素 思路异或(xor)运算的法则是相同为0,相异为1。遍历数组中全部元素,一一进行异或运算,那么可以发现相同的元素全部消除,留下的就是那个只出现一次的元素。 时间复杂度:O(n) 空间复杂度:O(1) 代码如下： public int singleNumber(int[] nums) &#123; int single = nums[0]; for(int i = 1;i&lt;nums.length;i++)&#123; single = single^nums[i]; &#125; return single;&#125; Single Number II题目内容Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one. 题目大意:给定一个元素数组,除了一个元素之外,每一个元素出现3次,找到这个元素。注意算法应该是线性的时间复杂度,能够不用额外的空间实现么？ 思路设置两个变量ones、twos分别代表出现一次和两次的情况,二者状态如下所示： 数字 出现一次 出现两次 出现三次 ones 记录 不记录 不记录 twos 不记录 记录 不记录 如上表所示,最终ones中仅仅记录了出现了一次的数字,而不记录出现三次的数字，最后返回ones即可。 代码如下： public int singleNumber(int[] A) &#123; int ones = 0, twos = 0; for(int i = 0; i &lt; A.length; i++)&#123; ones = (ones ^ A[i]) &amp; ~twos; twos = (twos ^ A[i]) &amp; ~ones; &#125; return ones;&#125; Single Number III题目内容Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. 题目大意:给定一个数组,里面有两个只出现一次的元素,找到这两个数字。两个数字的顺序问题可以忽略。 思路这个问题的思路可以借鉴第一个问题。首先,全部数字一一异或运算得到两个出现一次数字的异或结果;然后，找到这个异或值最低位为1的位置,这样可以将原来的数组的中数字分成两部分,一部分与这个数字异或为0，另一部分与这个数字异或为1，这样可以求出这个数字的值res[0]。最后将res[0]和xor异或，即可得到另外一个数字的值res[1]。 需要注意的是找到最低位为1的方法,如代码中所示,举例子说明例如：xor=111000,~xor=000111，那么对~xor加1在与xor相与即可得到最低位为1的值。 时间复杂度:O(n) 空间复杂度:O(1) 代码如下： public class Solution &#123; public int[] singleNumber(int[] nums) &#123; int[] res = &#123;0,0&#125;; int xor = 0; for(int i:nums)&#123; xor^=i;f &#125; int tmp = xor&amp;(~xor+1);//取得最低为1的值 for(int j:nums)&#123; if((j&amp;tmp)!=0)&#123; res[0]^=j;//数字分两组 &#125; &#125; res[1]=res[0]^xor; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序算法实现及优化分析]]></title>
    <url>%2F2017%2F02%2F24%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[快速排序(Quick Sort)是对冒泡排序的一种改进，基本思想是，随机选择一个分界值(pivot)，通过一趟排序将数字分成两部分，左边的部分都小于分界值，右边的部分都大于分界值。然后分别左右部分分别进行上述方式的划分，直到整个序列有序。 对于快速排序来说： 每一趟排序可以保证分界值落在最后的位置上 基本有序情况下退化成冒泡排序 算法实现递归方式对于每一次划分过程(partition)： 初始划分值是arr[right]，index表示当前遍历元素的下标，pivot表示分界值的下标(左边\&lt;=arr[right],右边>arr[right])。 遍历arr,若arr[index]\&lt;=arr[right],即当前元素小于划分值,将当前元素放入左半边数组中,实现方式是交换arr[pivot+1]和arr[index]的值,然后执行pivot++操作和index++操作。 若arr[index]>arr[right],暂时不移动(但是其右侧若有小于划分值的元素,则执行步骤3操作时会移动),执行index++操作。 遍历结束,左值小于等于arr[pivot],右边值大于arr[pivot],最后返回划分值的位置pivot。 代码如下： public class QuickSort &#123; public void quickSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; sort(arr, 0, arr.length - 1); &#125; //递归每一个划分部分进行排序 private static void sort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int random = left + (int) (Math.random() * (right - left + 1));//随机取出划分值 exch(arr, random, right);//将划分值放入right位置 int mid = partition(arr, left, right); //获取划分值位置 sort(arr, left, mid - 1); sort(arr, mid + 1, right); &#125; &#125; //每一趟排序,划分过程,得出划分值的位置 private static int partition(int[] arr, int left, int right) &#123; int pivot = left - 1; int index = left; while (index &lt;= right) &#123; //注意index=right的情况保证最后划分值移动到相应位置 if (arr[index] &lt;= arr[right]) &#123; exch(arr, ++pivot, index); //将元素移动至左边数组中 &#125; index++; &#125; return pivot; //返回划分值的位置 &#125; //交换两个数的值 private static void exch(int[] A, int i, int j) &#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125;&#125; 非递归方式递归实现的算法,理论上都可以通过非递归的方式实现,快排的非递归实现方式是更改sort()函数部分的代码。 思路如下： 申请一个栈记录每一次划分的left和right,初始化将数组的left和right入栈。 遍历栈中元素,若栈不空,弹出栈中最上面的两个元素分别right和left。 若left\&lt;right说明数组中还有未排序的元素,执行一次划分,得出划分的位置mid。 若left\mid+1，则将其入栈。 若栈空，停止遍历。 代码示例 private static void sort(int[] arr) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); stack.push(0); stack.push(arr.length - 1); while (!stack.isEmpty()) &#123; int right = stack.pop(); int left = stack.pop(); if(right&lt;=left)&#123; //注意判断条件 continue; &#125; int random = left + (int) (Math.random() * (right - left + 1));//随机取出划分值 exch(arr, random, right);//将划分值放入right位置 int mid = partition(arr,left,right); if(left&lt;mid-1)&#123; stack.push(left); stack.push(mid-1); &#125; if(right&gt;mid+1)&#123; stack.push(mid+1); stack.push(right); &#125; &#125; &#125; 快排优化优化思路： 对于分治思想的快排,若每次能将记录分成两个等长的记录，那么效率可以达到最好,如果情况相反，每次划分的两个记录长度差距悬殊，那么快排的将退化成冒泡排序。因此快排优化的思路是如何划分,即选好pivot。 目前有几种常见的选取pivot的方法： 固定位置 随机选取 三数取中 固定位置固定位置方法是每次的pivot都选择未排序元素中的第一个或者最后一个,优点是实现非常简单，缺点是如果元素基本有序的情况下，则变成了冒泡排序。 随机选取随机选取方法是在未排序元素中随机选取一个作为pivot,本文实现的就是采用这种方式。 三数取中将选取未排序元素中最左端、中间和最右端三个元素的中间值作为pivot,这样可有效处理基本有序的情况。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程(七)-Thread]]></title>
    <url>%2F2017%2F02%2F23%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B7%2F</url>
    <content type="text"><![CDATA[Java中实现线程有两种方式：继承Thread类和实现Runnable接口。其实Thead类也是实现了Runnable接口。无论是哪种方式，都需要重写run方法。 Thead类中有很多方法，下面介绍一些比较重要的方法。 join()join方法是在当前线程中让其他线程插队执行的方法，是对象方法。如果当线程A调用另一个线程B的join方法，当前线程A将等待线程B执行完成至销毁,然后A线程继续执行。相当于线程A中执行B.join(),则是让线程B插队执行。实际应用场景中比如开始游戏时加载资源线程A、线程B、线程C，三个线程全部完成后游戏主线程才能开始继续执行，代码示例如下： public class ThreadA &#123; public static void main(String[] args) throws InterruptedException &#123; ThreadB b = new ThreadB(); Thread t = new Thread(b); t.start(); for (int i = 0; i &lt; 5; i++) &#123; if (i == 3) &#123; t.join(); &#125; System.out.println(Thread.currentThread().getName() + ":" + i); &#125; &#125;&#125;class ThreadB implements Runnable &#123; public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + ":" + i); &#125; &#125;&#125; 输出结果： main:0main:1main:2Thread-0:0Thread-0:1Thread-0:2Thread-0:3Thread-0:4Thread-0:5Thread-0:6Thread-0:7Thread-0:8Thread-0:9main:3main:4 yeild()yield()是static方法，表示放弃当前处理器这次的资源，但是仅仅放弃一次执行的机会。例如有当前线程B、C，当B执行yeild()方法时，C线程得到调度的机会开始执行，代码示例如下： public class ThreadA &#123; public static void main(String[] args) throws InterruptedException &#123; ThreadB b = new ThreadB(); ThreadC c = new ThreadC(); Thread t1 = new Thread(b); Thread t2 = new Thread(c); t1.start(); t2.start(); &#125;&#125;class ThreadB implements Runnable &#123; public void run() &#123; for (int i = 1; i &lt;= 5; i++) &#123; if (i == 4) &#123; System.out.println(Thread.currentThread().getName() + ":" + i+":yield"); Thread.yield(); &#125;else&#123; System.out.println(Thread.currentThread().getName() + ":" + i); &#125; &#125; &#125;&#125;class ThreadC implements Runnable &#123; public void run() &#123; for (int i = 1; i &lt;= 5; i++) &#123; if (i == 2) &#123; System.out.println(Thread.currentThread().getName() + ":" + i+":yield"); Thread.yield(); &#125;else&#123; System.out.println(Thread.currentThread().getName() + ":" + i); &#125; &#125; &#125;&#125; 执行结果如下： Thread-0:1Thread-1:1Thread-0:2Thread-1:2:yieldThread-0:3Thread-0:4:yieldThread-1:3Thread-1:4Thread-1:5Thread-0:5 此外，Thread类中还有其他的方法，简略介绍 interrupt():中断一个线程 start():开始执行线程 run():调用线程时默认执行的方法]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程(六)-Fork/Join]]></title>
    <url>%2F2017%2F02%2F19%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B6%2F</url>
    <content type="text"><![CDATA[Fork/Join框架的主要类 ForkJoinTask\：描述任务的抽象类 ForkJoinPool：管理ForkJoinTask的线程池 RecursiveAction：ForkJoinTask子类，描述无返回值的任务 RecursiveTask\:ForkJoinTask子类，描述有返回值的任务 分而治之策略 将任务递归划分成更小的子任务，直到子任务足够小，从而能够被连续地处理掉为止 优势是处理过程可以使用并行发生，这种情况特别适合基于多核处理器的并行编程 根据Java API中定义，分而治之的建议临界点定义在100-1000个操作中的某个位置 Fork/Join代码示例:计算0-1000000的和 import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.Future;import java.util.concurrent.RecursiveTask;/** * Created by liuyang on 17/2/18. */public class ForkJoinDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ForkJoinPool forkJoinPool = new ForkJoinPool(); Future&lt;Long&gt; result = forkJoinPool.submit(new MyTask(0,10000001)); System.out.println(result.get()); forkJoinPool.shutdown(); &#125;&#125;class MyTask extends RecursiveTask&lt;Long&gt; &#123; static final int HOLD = 1000; private int begin, end; public MyTask(int begin, int end) &#123; this.begin = begin; this.end = end; &#125; @Override protected Long compute() &#123; long sum = 0; if ((end - begin) &lt; HOLD) &#123; for (int i = begin; i &lt; end; i++) &#123; sum += i; &#125; &#125; else &#123; int mid = (begin + end) / 2; MyTask left = new MyTask(begin, mid); left.fork(); MyTask right = new MyTask(mid, end); right.fork(); Long leftResult = left.join(); System.out.println(begin+"-"+mid+" : "+leftResult); Long rightResult = right.join(); System.out.println(mid+"-"+end+" : "+rightResult); sum = leftResult + rightResult; &#125; return sum; &#125;&#125; 代码输出： 3984375-4062500 : 3143310156253906250-4062500 : 6225585156253750000-4062500 : 12207029687504062500-4375000 : 13183592187503750000-4375000 : 25390621875004375000-5000000 : 29296871875003750000-5000000 : 54687493750002500000-5000000 : 93749987500000-5000000 : 124999975000005000000-10000001 : 3750000750000050000005000000]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程(五)-锁]]></title>
    <url>%2F2017%2F02%2F19%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B5%2F</url>
    <content type="text"><![CDATA[java.util.concurrent.lock包中提供了对锁的支持 为使用synchronized控制对资源访问提供了替代机制 基本操作模型： 访问资源之前申请锁，访问完毕后释放锁 lock/tryLock: 申请锁 unlock: 释放锁 具体锁类ReentrantLock实现了Lock接口 Lock代码示例 import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * Created by liuyang on 17/2/18. */public class LockDemo &#123; public static void main(String[] args)&#123; new MyThead().start(); new MyThead().start(); new MyThead().start(); new MyThead().start(); &#125;&#125;class Data &#123; static int i = 0; static Lock lock = new ReentrantLock(); static void operate() &#123; lock.lock(); i++; System.out.println(i); lock.unlock(); &#125;&#125;class MyThead extends Thread &#123; public void run() &#123; while (true) &#123; try &#123; Thread.sleep(1000); Data.operate(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 输出结果： 123456789101112]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程(四)-执行器]]></title>
    <url>%2F2017%2F02%2F19%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B4%2F</url>
    <content type="text"><![CDATA[执行器用于启动并控制线程执行 核心接口为Exceutor，包含一个execute(Runnable)用于指定被执行的线程 ExecutorService接口用于控制线程执行和管理线程 预定义了如下执行器：ThreadPoolExecutor/ScheduledThreadPoolExecutor/ForkJoinPool Callable与Future代码示例 import java.util.concurrent.*;/** * Created by liuyang on 17/2/18. */public class ExceutorDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ExecutorService executorService = Executors.newFixedThreadPool(2);//2个线程的线程池的执行器 Future&lt;Integer&gt; future1 = executorService.submit(new MC(1, 100));//Future&lt;V&gt;表示Callable的返回值 Future&lt;Integer&gt; future2 = executorService.submit(new MC(100, 10000)); System.out.println("future1:" + future1.get());//get获取返回值,Callable的执行结果 System.out.println("future2:" + future2.get());//get获取返回值,Callable的执行结果 executorService.shutdown();//停止执行器 &#125;&#125;//Callable&lt;V&gt;表示具有返回值的线程class MC implements Callable&lt;Integer&gt; &#123; private int begin, end; public MC(int begin, int end) &#123; this.begin = begin; this.end = end; &#125; //call执行任务 @Override public Integer call() throws Exception &#123; int sum = 0; for (int i = begin; i &lt;= end; i++) &#123; sum += i; &#125; return sum; &#125;&#125; 输出结果： future1:5050future2:50000050]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程(三)-CyclicBarrier、Phaser与CyclicBarrier]]></title>
    <url>%2F2017%2F02%2F18%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B3%2F</url>
    <content type="text"><![CDATA[CyclicBarrier(循环屏障):适用于只有多个线程都达到预定点时才可以继续执行,例如:斗地主一个人两人三个人才开始 Exchanger(交换器):简化两个线程间数据的交换 Phaser(同步器):工作方式与CyclicBarrier类似, 但是可以定义多个阶段 CyclicBarrier代码示例 import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;/** * Created by liuyang on 17/2/17. */public class CyclicBarrierDemo &#123; public static void main(String[] args) &#123; //设置等待线程的数量以及所有线程到达后的操作 CyclicBarrier cyclicBarrier = new CyclicBarrier(3, new Runnable() &#123; @Override public void run() &#123; System.out.println("Game start"); &#125; &#125;); new Player(cyclicBarrier, "A").start(); new Player(cyclicBarrier, "B").start(); new Player(cyclicBarrier, "C").start(); &#125;&#125;class Player extends Thread &#123; private CyclicBarrier cyclicBarrier; public Player(CyclicBarrier cyclicBarrier, String name) &#123; setName(name); this.cyclicBarrier = cyclicBarrier; &#125; public void run() &#123; System.out.println(getName() + " is waiting other players..."); try &#123; cyclicBarrier.await();//等待 System.out.println(getName()+" is playing"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出结果： A is waiting other players…C is waiting other players…B is waiting other players…Game startC is playingA is playingB is playing Phaser代码示例 import java.util.concurrent.Phaser;/** * Created by liuyang on 17/2/17. */public class PhaserDemo &#123; public static void main(String[] args) &#123; Phaser phaser = new Phaser(1);//使用指定数目线程创建Phaser System.out.println("starting...."); new Worker(phaser, "Waiter").start(); new Worker(phaser, "Cooker").start(); new Worker(phaser, "Food").start(); for (int i = 1; i &lt;= 3; i++) &#123; phaser.arriveAndAwaitAdvance(); //到达时等待到所有线程到达 System.out.println("Order:" + i + " finished"); &#125; phaser.arriveAndDeregister(); //到达时注销线程自己 System.out.println("All Done"); &#125;&#125;class Worker extends Thread &#123; private Phaser phaser; public Worker(Phaser phaser, String name) &#123; this.setName(name); this.phaser = phaser; phaser.register();//注册party &#125; public void run() &#123; for (int i = 1; i &lt;= 3; i++) &#123; System.out.println("current order is: " + i + " : " + getName()); if (i == 3) &#123; phaser.arriveAndDeregister(); &#125; else &#123; phaser.arriveAndAwaitAdvance(); &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 输出结果： starting….current order is: 1 : Cookercurrent order is: 1 : Waitercurrent order is: 1 : FoodOrder:1 finishedcurrent order is: 2 : Foodcurrent order is: 2 : Waitercurrent order is: 2 : CookerOrder:2 finishedcurrent order is: 3 : Cookercurrent order is: 3 : Waitercurrent order is: 3 : FoodOrder:3 finishedAll Done Exchanger代码示例 import java.util.concurrent.Exchanger;/** * Created by liuyang on 17/2/17. */public class ExchangerDemo &#123; public static void main(String[] args) &#123; Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;();//指定交换的数据类型 new A("A", exchanger).start(); new B("B", exchanger).start(); &#125;&#125;class A extends Thread &#123; private Exchanger&lt;String&gt; exchanger; public A(String name, Exchanger&lt;String&gt; exchanger) &#123; this.exchanger = exchanger; setName(name); &#125; public void run() &#123; String str = null; try &#123; str = exchanger.exchange("Hello");//等待线程到达，交换数据 System.out.println(getName() + " " + str); str = exchanger.exchange( "One"); System.out.println(getName() + " " +str); str = exchanger.exchange( "Two"); System.out.println(getName() + " " +str); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class B extends Thread &#123; private Exchanger&lt;String&gt; exchanger; public B(String name,Exchanger&lt;String&gt; exchanger) &#123; this.exchanger = exchanger; setName(name); &#125; public void run() &#123; String str = null; try &#123; str = exchanger.exchange( "Hi"); System.out.println(getName() + " " +str); str = exchanger.exchange( "1"); System.out.println(getName() + " " +str); str = exchanger.exchange("2"); System.out.println(getName() + " " + str); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出结果 A HiB HelloB OneA 1A 2B Two]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程(二)-Semaphore与CoundDownLatch]]></title>
    <url>%2F2017%2F02%2F18%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Semaphore(信号量):经典信号量，通过计数器控制对共享资源的访问 Semaphore代码示例 import java.util.concurrent.Semaphore;/** * Created by liuyang on 17/2/17. */public class SemaphoreDemo &#123; public static void main(String[] args) &#123; Semaphore semaphore = new Semaphore(2);//最多允许多少线程进入并发区域 Person p1 = new Person(semaphore, "A"); p1.start(); Person p2 = new Person(semaphore, "B"); p2.start(); Person p3 = new Person(semaphore, "C"); p3.start(); &#125;&#125;class Person extends Thread &#123; private Semaphore semaphore; public Person(Semaphore semaphore, String name) &#123; setName(name); this.semaphore = semaphore; &#125; public void run() &#123; System.out.println(getName() + " is waiting..."); try &#123; semaphore.acquire();//获取信号量 System.out.println(getName() + " is servicing..."); Thread.sleep(1000); semaphore.release();//释放信号量 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + " is done!"); &#125;&#125; 输出结果： A is waiting…C is waiting…B is waiting…C is servicing…A is servicing…A is done!B is servicing…C is done!B is done! CoundDownLatch(计数拴):必须发生指定数量的事件后才可以继续运行 CoundDownLatch代码示例 import java.util.concurrent.CountDownLatch;/** * Created by liuyang on 17/2/17. */public class CoundDownLatchDemo &#123; public static void main(String[] args) &#123; CountDownLatch countDownLatch = new CountDownLatch(3);//计数拴到0的时候线程才能够执行 new Racer(countDownLatch, "A").start(); new Racer(countDownLatch, "B").start(); new Racer(countDownLatch, "C").start(); for (int i = 0; i &lt; 3; i++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(countDownLatch.getCount()); countDownLatch.countDown(); if (i == 2) &#123; System.out.println("start"); &#125; &#125; &#125;&#125;class Racer extends Thread &#123; private CountDownLatch countDownLatch; public Racer(CountDownLatch countDownLatch, String name) &#123; setName(name); this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; try &#123; countDownLatch.await(); for (int i = 0; i &lt; 3; i++) &#123; System.out.println(getName() + " : " + i); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出结果： 321startB : 0B : 1B : 2A : 0A : 1A : 2C : 0C : 1C : 2]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程(一)-并发工具简介]]></title>
    <url>%2F2017%2F02%2F17%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[并发工具概述 同步器：为每种特定的同步问题提供了解决方案 执行器：用来管理线程的执行 并发集合：提供了集合框架中集合的并发版本 Fork/Join：提供了对并行编程的支持 atomic包：提供了不需要锁即可完成并发环境变量使用的原子性操作 locks包：使用Lock接口为并发编程提供了同步的另外一种替代方案 同步器 Semaphore(信号量):经典信号量，通过计数器控制对共享资源的访问 CoundDownLatch(计数拴):必须发生指定数量的事件后才可以继续运行 CyclicBarrier(循环屏障):适用于只有多个线程都达到预定点时才可以继续执行,例如:斗地主一个人两人三个人才开始 Exchanger(交换器):简化两个线程间数据的交换 Phaser(同步器):工作方式与CyclicBarrier类似, 但是可以定义多个阶段 执行器 执行器用于启动并控制线程执行 核心接口为Exceutor，包含一个execute(Runnable)用于指定被执行的线程 ExecutorService接口用于控制线程执行和管理线程 预定义了如下执行器：ThreadPoolExecutor/ScheduledThreadPoolExecutor/ForkJoinPool Fork/Join框架Fork/Join框架的主要类 ForkJoinTask\：描述任务的抽象类 ForkJoinPool：管理ForkJoinTask的线程池 RecursiveAction：ForkJoinTask子类，描述无返回值的任务 RecursiveTask\:ForkJoinTask子类，描述有返回值的任务 分而治之策略 将任务递归划分成更小的子任务，直到子任务足够小，从而能够被连续地处理掉为止 优势是处理过程可以使用并行发生，这种情况特别适合基于多核处理器的并行编程 根据Java API中定义，分而治之的建议临界点定义在100-1000个操作中的某个位置]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最佳交易股票时间系列问题（Best Time to Buy and Sell Stock）]]></title>
    <url>%2F2017%2F01%2F15%2F%E6%9C%80%E4%BD%B3%E4%BA%A4%E6%98%93%E8%82%A1%E7%A5%A8%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本篇文章是在实验室算法分享讲座时的内容 Best Time to Buy and Sell Stock题目：Say you have an array for which the ith element is the price of a given stock on day i.If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. 大意：给定一个整型数组,第i个元素代表第i天股票的价格,如果只允许你最多完成一次交易,即买一个股票然后再卖一次股票,设计一个算法求得交易的最大值。 样例： Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) 分析：本质上求出有序数组中两个最大的差值，即后面元素减去前面元素的最大值 方法一：暴力法思路：遍历数组prices，求出每一个元素prices[i]作为最小值的情况下，获得的收益最大值 举例： cur表示当前元素作为最小值的情况下，完成一次交易获得收益的最大值 max表示截止到当前元素，完成一次交易获得收益的最大值 7 1 5 3 6 4 cur 0 5 1 3 0 0 max 0 5 5 5 5 5 复杂度：时间复杂度O(n2),空间复杂度O(1) 代码： public int maxProfit(int[] prices) &#123; int max = 0; for(int i=0;i&lt;prices.length;i++)&#123; for(int j=i;j&lt;prices.length;j++)&#123; int profit = prices[j] - prices[i]; max = profit&gt;max?profit:max; &#125; &#125; return max; &#125; 方法二：记录最小值法思路： 1、设置一个变量min表示截止到当前元素为止，前i个元素中的最小值，min初始值为Integer.MAX_VALUE；设置变量cur表示当前天数的收益值,初始值为0；设置变量max表示截止当前天数为止，完成一次交易获得收益的最大值。 2、遍历数组prices,将元素prices[i]\&lt;min,则更新min的值 3、若cur>max，则更新max 举例： 7 1 5 3 6 4 min 7 1 1 1 1 1 cur 0 0 4 2 5 3 max 0 0 4 4 5 5 复杂度：时间复杂度O(n),空间复杂度O(1) 代码： public int maxProfit(int[] prices) &#123; int max = 0; int min = Integer.MAX_VALUE; for (int i = 0; i &lt; prices.length; i++) &#123; min = Math.min(min, prices[i]); max = Math.max(max,prices[i]-min); &#125; return max; &#125; 方法三：动态规划方法思路： 转化为连续子数组的最大和问题 1、设置变量profit表示股票当前价格和前一天价格的差值,初始值为0；设置变量cur表示当天必须参加交易的情况下,获得收益的最大值；设置变量max表示截止当前天数为止，完成一次交易获得收益的最大值。 7 1 5 3 6 4 profit 0 -6 4 -2 3 -2 cur 0 -6 4 2 5 2 max 0 0 4 4 5 5 复杂度：时间复杂度O(n),空间复杂度O(1) 代码： public int maxProfit(int[] prices) &#123; int max = 0; int cur = 0; for(int i=1;i&lt;prices.length;i++)&#123; cur = Math.max(0,cur+prices[i]-prices[i-1]); max = Math.max(max,cur); &#125; return max; &#125; Best Time to Buy and Sell Stock II题目：Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 大意：给定一个整型数组,第i个元素代表第i天股票的价格,允许完成多次交易,但是不允许同时拥有多张股票(例如:你在买另一张股票之前必须卖出股票) 样例： Input: [7, 1, 5, 3, 6, 4]Output: 7 分析： 方法一：动态规划法思路： 下,获得收益的最大值；设置变量max表示截止当前天数为止，完成一次交易获得收益的最大值。 7 1 5 3 6 4 profit 0 -6 4 -2 3 -2 max 0 0 4 4 7 7 复杂度：时间复杂度O(n),空间复杂度O(1) 代码： public int maxProfit(int[] prices) &#123; int cur = 0; for (int i = 1; i &lt; prices.length; i++) &#123; int profit = prices[i] - prices[i - 1]; cur = profit &gt; 0 ? cur + profit : cur; &#125; return cur; &#125; Best Time to Buy and Sell Stock III题目：Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete at most two transactions. 大意：给定一个整型数组,第i个元素代表第i天股票的价格,设计一个算法找到最大的收益,允许最多进行两次交易。但是不允许同时拥有多张股票(例如:你在买另一张股票之前必须卖出股票)。 样例： Input: [7, 1, 5, 3, 6, 4]Output: 7 分析： 1、可以进行一次交易；进行两次交易 方法一：暴力法思路： 复杂度：时间复杂度O(n2),空间复杂度O(1) 代码： public int maxProfit(int[] prices) &#123; int max = 0; for (int i = 0; i &lt; prices.length; i++) &#123; int cur = maxPartProfit(0, i, prices) + maxPartProfit(i, prices.length, prices); max = cur &gt; max ? cur : max; &#125; return max; &#125; public int maxPartProfit(int begin, int end, int[] prices) &#123; int max = 0; int profit = 0; if (prices == null || prices.length == 0) &#123; return max; &#125; int min = prices[begin]; for (int i = begin; i &lt; end; i++) &#123; if (prices[i] &lt;= min) &#123; min = prices[i]; &#125; else &#123; profit = prices[i] - min; max = profit &gt; max ? profit : max; &#125; &#125; return max; &#125; 方法二：记忆搜索法思路：1、设置两个数组left和right，left[i]表示从左至右遍历时前i个元素的最大收益，right[j]表示从右至左遍历时，后i个元素的最大收益。cur变量表示将当前天数分成两次交易时,前i天和后j天收益的最大值，res变量表示当前交易两次的最大值。 2、遍历两次，生成数组left和right 3、 举例： 7 1 5 3 6 4 left 0 0 4 4 5 5 right 5 5 3 3 0 0 cur 5 5 7 7 5 5 res 5 5 7 7 7 7 复杂度：时间复杂度O(n),空间复杂度O(n) 代码： public int maxProfit(int[] prices) &#123; int cur = 0; if (prices == null || prices.length == 0) &#123; return cur; &#125; int len = prices.length; int min = prices[0]; int[] left = new int[len]; left[0] = 0; //从左至右遍历 for (int i = 1; i &lt; len; i++) &#123; min = prices[i] &lt; min ? prices[i] : min; int profit = prices[i] - min; left[i] = profit &gt; left[i - 1] ? profit : left[i - 1]; &#125; int max = prices[len - 1]; int[] right = new int[len]; right[len - 1] = 0; //从右向左遍历 for (int j = len - 2; j &gt;= 0; j--) &#123; max = prices[j] &gt; max ? prices[j] : max; int profit = max - prices[j]; right[j] = profit &gt; right[j + 1] ? profit : right[j + 1]; &#125; int res = 0; for (int k = 0; k &lt; len; k++) &#123; cur = left[k] + right[k]; res = res &gt; cur ? res : cur; &#125; return res; &#125; Best Time to Buy and Sell Stock IV题目：Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. 大意：给定一个整型数组,第i个元素代表第i天股票的价格,设计一个算法找到最大的收益,允许最多进行k次交易。但是不允许同时拥有多张股票(例如:你在买另一张股票之前必须卖出股票)。 样例： Input: [7, 1, 5, 3, 6, 4]Output: 7 分析：求出前k段的最大值 方法一：动态规划 res=Math.max(res[i-1][j],res[i-1][j-1]+profit) 问题： 1、应该合并交易 举例 profit price 1 2 0 1 0 0 4 5 4 4 -3 2 4 4 2 4 4 6 3 7 6 7 用local表示到达第i天时，最多进行j次交易的局部最优解；用global表示到达第i天时，最多进行j次的全局最优解。它们二者的关系如下： local[i][j] = Math.max(global[i – 1][j – 1] , local[i – 1][j] + profit)global[i][j] = Math.max(global[i – 1][j], local[i][j]) local表示第i天一定有交易发生 举例 local profit price 1 2 0 1 0 0 4 5 4 4 -3 2 4 4 2 4 4 6 3 7 6 9 global profit price 1 2 0 1 0 0 4 5 4 4 -3 2 4 4 2 4 4 6 3 7 6 9]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解TCP和UDP]]></title>
    <url>%2F2017%2F01%2F10%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%92%8CUDP%2F</url>
    <content type="text"><![CDATA[OSI七层模型中,传输层(Transport Layer)为应用进程提供端到端的通信服务。传输层的协议主要包括TCP和UDP等协议。 TCP的全称是Transmission Control Protocol,即传输控制协议。TCP是面向连接的、可靠的流协议。TCP通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。此外，还具备流量控制、拥塞控制和提高网络利用率等众多功能。 UDP的全称是User Datagram Protocol,即用户数据报协议。UDP是一个非常简单的传输层协议，并不提供可靠性。因此，UDP经常应用在以下几个方面： 包总量较少的通信（DNS、SNMP） 视频、音频等多媒体通信（即时通信） 限定于LAN等特定网络中的应用通信 广播通信（广播、多播） 数据格式TCP通信过程中传递的数据单位是报文段,每一个报文段的首部是20字节，如下图所示 Sequence Number(Seq):代表序列号，按顺序给发送数据的每一个字节（8位字节）都标上号码的编号。确认应答处理、重发控制以及重复控制等功能都可以听过序列号实现。 Acknowledgment Number(ACK):负责确认应答，当发送端的数据达到接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答(ACK)。 TCP Flags：标识位,其中S表示SYN，代表同步序号；F表示FIN，代表完成数据发送；R表示RST，代表复位连接；P表示PSH，尽快发送数据，以上的标志用bit的0或1表示。 Window：窗口大小,用于流量控制和拥塞控制。 连接管理TCP是一个面向连接的协议，因此在正式发送数据之前需要在通信的双方建立一条连接。同样，在完成数据传递后需要双方将通信的连接断开。正常的通信过程至少来回发送7个包才能够完成，这就是所谓的三次握手、四次挥手。 TCP状态图说明 实线：代表客户端的正常状态变迁 虚线：代表服务器的正常状态变迁 应用进程：说明当应用执行某种操作时发生的状态变迁 收：说明当收到TCP报文段时状态变迁 发：说明为了进行某个状态变迁要发送的TCP报文段 流量控制拥塞控制参考文献https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82 https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解HTTP》读书笔记]]></title>
    <url>%2F2016%2F12%2F29%2F%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第1章URI和URLURL(Uniform Resource Locator,统一资源定位符)是Web浏览器等Web页面需要输入的网页地址。 URI(Uniform Resource Identifier,统一资源标识符)是由某个协议方案表示的资源的定位表示符号。其中,Uniform表示统一格式的各种协议。 URI用字符串标识某一互联网资源，而URL表示资源的地点(互联网上所处的位置)，因此URL是URI的子集。 URI的格式: scheme://\[user:password@host:port]/path?query#fragment 例如： hierarchical part ┌───────────────────┴─────────────────────┐ authority path ┌───────────────┴───────────────┐┌───┴────┐ abc://username:password@example.com:123/path/data?key=value&amp;key2=value2#fragid1 └┬┘ └───────┬───────┘ └────┬────┘ └┬┘ └─────────┬─────────┘ └──┬──┘ scheme user information host port query fragment urn:example:mammal:monotreme:echidna └┬┘ └──────────────┬───────────────┘ scheme path 问题：最后的fragment的用处？ 第2章 简单的HTTP协议HTTP支持的方法 GET 获取资源 POST 传输实体主体 PUT 传输文件 HEAD 获得报文首部 DELETE 删除文件 OPTIONS 询问支持的方法 TRACE 追踪路径 CONNECT 要求用隧道协议连接代理 第3章 HTTP报文内的HTTP信息HTTP报文内的HTTP信息报文主体和实体主体的差异 报文(message)是HTTP通信的基本单位，由8位组字节流(octet sequence,octet为8个比特)组成，通过HTTP通信传输。 实体(entity)是作为请求或相应的有效载荷数据(补充项)被传输，其内容有实体首部和实体主体组成。 HTTP报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体，只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。 第4章 返回结果的HTTP状态码状态码的类别 1XX：Informational(信息性状态码),接收的请求正在处理 2XX：Success(成功状态码),请求正常处理完毕 3XX：Redirection(重定向状态码),需要进行附加操作以完成请求 4XX：Client Error(客户端错误代码)服务器无法处理请求 5XX：Server Error(服务器错误代码)服务器处理请求出错 第5章 与HTTP写作的Web服务器通信数据转发程序：代理、网关、隧道HTTP通信时,除客户端和服务器以外，还有一些用于通信数据转发的应用的程序，例如代理、网关和隧道。 代理：是一种有转发功能的应用程序，接收由客户端发送的请求并转发给服务器,同时也接收服务器返回的响应并转发给客户端。 网关：转发其他服务器通信数据的服务器,接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。 隧道：隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。 代理服务器的使用理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的。代理有多种使用方法，按两种基准分类，一种是是否使用缓存，另一种是是否会修改报文。 网关能够使通信线路上的服务器提供非HTTP协议服务器。利用网关能提高通信的全安性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询。 隧道可以按照要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。 第6章 HTTP首部第7章 确保Web安全的HTTPSHTTP主要下面这些不足： 通信使用明文（不加密），内容可能会被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法证明报文的完整性，所以有可能已遭篡改 加密的对象： 一种方式是通信的。HTTP中没有加密机制，但是和通过SSL(Secure Socket Layer,安全套接层)或TLS(Transport Layer Security,安全层传输协议)的组合使用，加密HTTP的通信内容。与SSL组合使用的HTTP被称为HTTPS(HTTP Secure,超文本传输安全协议)或HTTP over SSL。另一种方式是将通信的内容本身进行加密。 HTTP协议本身非常简单，不论是谁发送过来的请求都会返回相应，因此不确认通信方，会存在以下各种隐患： 无法确定请求发送至目标的Web服务器是否是按真实的意图返回响应的服务器。有可能是伪装的Web服务器 无法确定响应返回到的客户端是否是按照真实意图接收响应的那个客户端。有可能是已伪装的客户端。 无法确定正在通信的对方是否具备访问权限。因为某些Web服务器上保存着重要的信息，只想发给特定用户通信的权限。 无法判定请求是来自何方、出自谁手。 即使是无意义的请求也会照单全收。无法阻止海量请求下的DoS攻击(Denial of Service,拒绝服务攻击)。 HTTP+加密+认证+完整性保护=HTTPSHTTPS的缺点：加密通信会消耗更多的CPU和内存资源。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Java多线程编程核心技术》读书笔记]]></title>
    <url>%2F2016%2F12%2F20%2F%E3%80%8AJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[个人理解 多线程的意义： 对于单核CPU来说，在执行多任务时，能够提前将耗时较小的任务执行完毕。 对于多核CPU来说，在执行多任务时，能够将任务分配多个CPU进行处理，减少计算时间。 第1章 Java多线程技能主要是介绍Thread类中的核心方法，主要掌握下面关键技术点： 线程的启动 如何使线程暂停 如何使线程停止 线程的优先级 想成安全相关的问题 使用多线程 继承Thread类 实现Runnable接口 非线程安全主要是指多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改、值不同步的情况，进而影响程序的执行流程。 currentThread()方法currentThread()方法可返回代码段正在被哪个线程调用的信息。 isAlive()方法isAlive()方法的功能是判断当前的线程是否处于活动状态。活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备开会运行的状态，就认为线程是“存活”的。 sleep()方法sleep()方法的作用是在指定的毫秒数内让当前“正在执行的线程”休眠(暂停执行)。这个“正在执行的线程”是指this.currentThread()返回的线程。 getId()方法getId()方法的作用是取得线程的唯一标识。 停止线程停止一个线程意味着在线程处理完成任务之前停掉正在做的操作，也就是放弃当前的操作。停止一个线程可以使用Thread.stop()方法，但最好不使用，因为这个方法是不安全的。大多数停止一个线程的操作使用Thread.interrupt()方法，尽管方法的名称是“停止，中止”，但是这个方法不会终止一个正在运行的线程，还需要加入一个判断才可以完成线程的停止。 在Java中有一下3种方法可以终止正在运行的线程： 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。 使用stop方法强行终止线程，但是不推荐使用这个方法，因为stop和suspend及resume一样都是作废过期的方法，使用它们可能产生不可预料的结果。 使用interrupt方法终端线程。 调用interrupt()方法仅仅是在当前线程中打了一个停止的标记，并不是真的停止线程。 this.interrupt()：测试当前线程是否已经是中断状态，执行后具有将状态标志置清除为false的功能。 this.isInterrupted()：测试线程Thread对象是否已经是中断状态，但不清除状态标志。 暂停线程在Java多线程中，可以使用suspend()方法暂停线程，使用resume()方法恢复线程的执行。 缺点： 独占，如果使用不当，极易造成公共的同步对象的独占，使其他线程无法访问公共同步对象。 不同步，容易出现因为线程的暂停而导致数据不同步的情况。 yield方法yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU的时间片。 线程的优先级设置线程的优先级使用setPriority()方法，在Java中，线程的优先级分为110这10个等级，如果小于1或大于10，则JDK抛出异常。 守护线程Java线程中有两种线程，一种是用户线程，另外一种守护(Daemon)线程。守护线程是一种特殊的线程，他的特性有陪伴的含义，当进程中没有非守护线程了，则守护线程自动销毁。典型的守护线程就是垃圾回收线程。 第2章 对象及变量的并发访问主要介绍Java多线程中的同步，也就是如何在Java语言中写出线程安全的程序，如何在Java语言中解决非线程安全的相关问题。主要掌握的技术要点如下： synchronized对象监视器为Object时的使用 synchronized对象监视器为Class时的使用 非线程安全是如何出现的 关键字volatile的主要作用 关键字volatitle与synchronized的区别及使用情况 synchronized同步方法“非线程安全问题”其实会在多个线程对同一个对象中的实例变量进行并发访问时发生，产生的后果就是“脏读(dirtyRead)“,也就是渠道的数据其实是被更改过的。 “非线程安全”问题存在于“实例变量“中，如果是方法内部的私有变量，则不存在“非线程安全”问题。 调用关键字synchronized声明的方法一定是排队运行的。另外记住“共享”两个字，只有共享资源的读写访问才需要同步化，如果不是共享资源，那么根本没有同步的必要。 当A线程调用anyObject对象加入synchronized关键字的X方法时，A线程就获得了X方法锁，更准确的讲是获得了对象的锁。所以其他线程必须等A线程执行完毕才能调用X方法，但B线程可以调用其他的非synchronized同步方法。 关键字synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时是可以再次得到该对象的锁的。“可重入锁”的概念是：自己可以再次获得自己的内部锁。比如有1条线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果锁不可重入的话就会造成死锁。 当一个线程执行的代码出现异常时，其所持有的锁会自动释放。 同步不可继承。 synchronized同步语句块用关键字synchronized声明方法在某些情况下是有弊端的，比如A线程调用同步方法执行一个长时间的任务，那么B线程则必须等待比较长时间。在这样的情况下可以使用synchronized同步语句块来解决。synchronized方法是对当前对象进行加锁，而synchronized代码块是对某一个对象进行加锁。 当两个并发线程访问同一个对象Object中的synchronized(this)同步代码块时,一段时间内只能有一个线程被执行，另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。 synchronized代码块间的同步性：在使用同步sychronized(this)代码块时需要注意的是，当一个线程访问Object的一个synchronized(this)同步代码块时，其他线程对同一个Object中其他所有synchronized(this)同步代码块的访问将被阻塞，这说明synchronized使用的“对象监视器”是一个。 将任一对象作为对象监视器：多个线程调用同一个对象的不同名称的synchronized同步方法或synchronized(this)同步代码块时，调用的效果就是按顺序执行，也就是同步的，阻塞的。这就说明synchronized 同步方法有两种作用： 对其他的synchronized同步方法或synchronized(this)代码块调用呈阻塞状态。 同一时间只有一个线程可以执行synchronized同步方法中的代码。 “synchronized(非this对象x)”格式的写法是将x对象本身作为“对象监视器“,这样可以得出以下3个结论： 当多个线程同时执行synchronized(x){}同步代码块时呈现同步效果。 当其他线程执行x对象中synchronized同步方法时呈同步效果。 当其他线程执行x对象方法俩面的synchronized(this)代码块时也呈现同步效果。 但需要注意的是，如果其他线程调用不加synchronized关键字的方法时，还是异步调用。 静态同步synchronized方法与synchronized(this)代码块：关键字 synchronized还可以应用在static静态方法上，是对当前的*.java文件对应的 Class类进行持锁。 数据类型String的常量池特性：将synchronized(String)同步块与String联合使用时，要注意常量池带来的一些例外。因此，在大多数的情况下，同步synchronized代码块都不使用String作为锁的对象。 volatile关键字关键字volatile的主要作用是使变量在多个线程间可见。关键字volatile强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值。使用volatile关键字增加了实例变量在多个线程之间的可见性。但valatile关键字最致命的缺点是不支持原子性。 关键字synchronized和volatile的比较： 关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且volatile是能修饰变量，而synchronized可以修饰方法，以及代码块。 多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。 volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为他会将私有内存和公共内存中的数据做同步。 关键字volatile解决的是变量在多个线程之间的可见性；而synchronized关键字解决的是多个线程之间访问资源的同步性。 线程安全包含原子性和可见性两个方面，Java的同步机制都是围绕这两个方面来确保线程安全的。 表达式i++的操作步骤如下： 1、从内存中取出i的值 2、计算i的值 3、将i的值写到内存中 假如在第2步计算值的时候，另外一个线程也修改i的值，那么就会出现脏数据。 第3章 线程间通信主要掌握的技术点如下： 使用wait/notify实现线程间的通信。 生产者/消费者模式的实现 方法join的使用 ThreadLocal类的使用 等待/通知机制等待/通知机制的实现 wait和notify：wait使线程停止运行，notify使停止的线程继续运行。 方法wait()的作用是使当前执行代码的线程进行等待，wait()方法是Object类的方法，该方法用来将当前线程置入“预执行队列”中，并且在wait()所在的代码行处停止执行，直到接到通知或中断为止。 方法notify()也要在同步方法或同步块中调用。即在调用前，线程也必须获得该对象的对象级别锁。 需要注意的是在执行notify()方法后，当前线程不会马上释放该对象锁，要等到notify()方法的线程将程序执行完，也是退出synchronized代码块后，当前线程才会释放锁。 线程的状态切换 1）新创建一个线程对象后，再调用它的start()方法，系统会为此线程分配CPU资源，使其处于Runnable(可运行)状态，这是一个准备运行的阶段。如果线程抢占到CPU资源，此线程就处于Running(运行)状态。 2）Runnable状态和Running状态可相互切换，因为有可能线程运行一段时间后，有其他高优先级线程抢占了CPU资源，此时线程从Running状态变成了Runnable状态。 线程进入Runnable状态大体分以下5种情况： 调用sleep()方法后经过的时间超过了指定的休眠时间 线程调用的阻塞IO已经返回，阻塞方法执行完毕 线程成功获得了试图同步的监视器 线程正在等待某个通知，其他线程发出了通知 处于挂起状态的线程调用了resume恢复方法 3）Blocked是阻塞的意思，例如遇到了一个IO操作，此时CPU处于空闲状态，可能会转而把CPU时间片分配给其他线程，这时也可以称为“暂停”状态。Blocked状态结束后，进入Runnable状态，等待系统重新分配资源。 出现阻塞的情况大体分下面5种： 线程调用了sleep方法，主动放弃占用的处理器资源 线程调用了阻塞式IO方法，在该方法返回前，该线程被阻塞 线程视图获得一个同步监视器，但该同步监视器正在被其他线程所持有 线程等待某个通知 程序调用了suspend方法将该线程挂起。此方法容易导致死锁，尽量避免使用该方法。 4）run()方法运行结束后进入销毁阶段，整个线程执行完毕。 每个对象都有两个队列，一个是就绪队列，一个是阻塞队列。就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程。 方法wait()锁释放与notify()锁不释放 方法wait()被执行后，锁自动释放，但执行完notify()方法后，锁却不自动释放。sleep方法不释放锁。 方法join的使用方法join()的作用是等待线程对象销毁。例如，主线程创建并启动子线程后，子线程中执行大量的耗时操作，如果此时主线程想等待子线程完成之后再结束，此时执行需要用到join方法。 方法join具有是线程排队运行的作用，有些类似同步的运行效果。join与synchronized的区别是：join内部使用wait()方法进行等待，而sychronized关键字使用的是“对象监视器”原理作为同步。 方法join(long)与sleep(long)的区别：join(long)方法具有释放锁的特点，而Thread.sleep(long)方法却不释放锁。 类ThreadLocal的使用变量值共享可以使用public static变量的形式，所有线程都使用同一public static变量。如果每一个线程都想有自己的共享变量呢?ThreadLocal正是为了解决这样的问题。 类ThreadLocal主要解决的是每个线程绑定自己的值。 类InheritableThreadLocal的使用类InheritatbleThreadLocal可以在子线程中取得父线程继承下来的值。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库知识总结]]></title>
    <url>%2F2016%2F12%2F13%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[SQL语言SQL 概念：SQL(Structured Query Language),即结构化查询语言，是关系数据库的标准语言。 数据查询语言(Data Query Language,DQL):SELECT 数据定义语言(Data Define Language,DDL):CREATE,DROP,ALTER 数据操作语言(Data Manipulation Language,DML):INSERT,UPDATE,DELETE 数据控制语言(Data Control Language,DCL):GRANT,REVOKE 语法顺序： SELECT(DISTINCT) FROM WHERE GROUP BY HAVING UNION ORDER BY 执行顺序： FROM WHERE GROUP BY HAVING SELECT DISTINCT UNION ORDER BY drop、delete和truncate三者的区别 delete和truncate只删除表的数据不删除表的结构 速度:drop>truncate>delete delete语句是DML，这个操作将会放到rollback segment中，事务提交之后才生效；如果有相应的trigger，执行的时候将被触发。truncate，drop是DDL，操作立即生效，原数据不放到rollback segment中，不能回滚，操作不触发trigger。 drop、delete和truncate的使用场景 不需要一张表的时候，用drop 想删除部分数据行的时候，用delete，并且带上where子句 保留表而删除所有数据的时候用truncate 概念存储过程 概念：存储过程(Stored Procedure)由一些SQL语句组成的代码块，这些代码块像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，用到这个功能的时候调用即可。 优点： 由于数据库执行动作时，是先编译后执行的，而存储过程是一个编译过的代码块，所以执行效率比SQL语句要高 一个存储过程的程序在网络中可以代替大量的SQL语句，因此能够降低网络通信量，提高通信速率 存储过程能够使没有权限的用户在控制下间接的存取数据库，从而保证数据的安全 缺点： 调试问题 移植问题，数据库端的代码是与数据库相关的 重新编译问题 触发器 概念：触发器(TRIGGER)是一种特殊的存储过程，它在插入、删除或修改特定表中的数据时触发执行，它比数据库本身标准的功能有更精细和更复杂的数据控制能力。 作用： 安全性，可以基于数据库的值是用户具有操作数据库的某种权利 审计，可以跟踪用户对数据库的操作 实现复杂的数据完整性规则 实现复杂的非标准的数据库相关完整性规则 同步实时地复制表中的数据 自动计算数据值 缺点： 同存储过程 注意事项： 只有表才可以支持触发器，视图和临时表都不支持触发器 每个表的每个事件只支持一个触发器，因此一个表最多支持6个触发器 单一触发器不能与多个操作相关 触发器不能更新和覆盖，如果想更新一个触发器必须先删除，再创建 索引 概念：索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构。MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引。 作用： 索引加快了数据库的检索速度 索引降低了插入、删除、修改等维护任务的任务 唯一索引可以确保每一行数据的唯一性 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统性能 索引需要占物理和数据空间 事务 概念：事务(Transaction)是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。 事务的四个属性(统称为ACID特性)： 原子性(Atomicity):事务中的所有元素作为一个整体提交或回滚，事务的元素是不可分的，事务是一个完整操作。 一致性(Consisteny):事务完成时，数据必须是一致的，也就是说和事务开始之前，数据存储中的数据处于一致状态，保证数据无损。 隔离性(Isolation):对数据进行修改的多个事务是彼此隔离的。这表明事务必须是独立的，不应该以任何方式影响其他事务。 持久性(Durability): 事务完成后，它对于系统的影响是永久的，该修改即使出现系统故障也将一直保留，真实的修改了数据库。 乐观锁和悲观锁 概念：数据库管理系统(DBMS)中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性、统一性以及数据库的统一性。乐观并发控制(乐观锁) 和悲观并发控制(悲观锁)是并发控制主要采用的技术手段。 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 优缺点： 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。 超键、候选键、主键、外键 超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 候选键：是最小超键，即没有冗余元素的超键。 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。 外键：在一个表中存在的另一个表的主键称此表的外键,外键可以重复或空值。 视图 概念：视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增、改和查操作，视图通常是一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它是我们获取数据更容易。 特点： 只暴露部分字段给访问者，所有就建一个虚表，就是视图。 查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源不同表所带来的差异。 范式 第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。 第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。 第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大型分布式网站架构架构设计与实践》读书笔记]]></title>
    <url>%2F2016%2F11%2F19%2F%E3%80%8A%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[书名：《大型分布式网站架构设计与实践》作者：陈康贤(龙隆) 第一章 面向服务的体系结构(SOA)RPC的全称是Remote Process Call，即远程过程调用，拥有RMI、WebService等诸多成熟的方案。 对象序列化： 将对象转换为二进制流的过程称为对象的序列化 将二进制流恢复为对象的过程称为对象的反序列化 RPC实现方式： 基于TCP协议的RPC 优点：协议栈下层，灵活对协议字段定制，降低网络开销，提高性能，实现更大的吞吐量和并发数 缺点：需要更多的关注底层复杂的细节，较难实现跨平台的调用 基于HTTP协议的RPC 优点：无需关注底层细节，通过使用JSON或XML格式相应数据，实现跨平台， 缺点：传输所占字节数多导致效率相对TCP方式低(可以通过gzip数据压缩)负载均衡算法的实现(P33) ZooKeeper是Hadoop下的一个子项目，它是一个针对大型分布式系统的可靠的协调系统，提供的功能包括配置维护、名字服务、分布式同步、组服务等。 第二章 分布式系统基础设施 分布式缓存 持久化存储 消息系统 垂直化搜索引擎 其他基础设施(实时计算、离线计算、分布式文件系统、日志搜集系统、监控系统、数据仓库、CDN系统、负载均衡系统、消息推送系统、自动化运维系统) 第三章 互联网安全架构第四章 系统稳定性日志分析常用命令 cat：查看文件内容(小文件) more：查看文件内容(支持分页) less：查看文件内容(支持查找) wc：统计文件中的字符数、字数、行数 grep：查找文件中的字符串 find：查找文件 sort：内容排序 head：显示文件头 tail：显示文件尾 日志分析脚本 seq编辑器 awk程序 shell脚本 第五章 数据分析]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大型网站技术架构核心原理与案例分析》读书笔记]]></title>
    <url>%2F2016%2F11%2F03%2F%E3%80%8A%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[书名：《大型网站技术架构-核心原理与案例分析》作者：李智慧 第一章 大型网站架构演化发展历程 应用服务和数据服务分离 使用缓存改善网站性能 使用应用服务器集群改善网站的并发处理能力 数据库读写分离 使用反向代理和CDN加速网站响应 使用分布式文件系统和分布式数据库系统 使用NoSQL和搜索引擎 业务拆分 分布式服务 第三章 大型网站核心架构要素 性能 可用性 伸缩性 拓展性 安全性 第四章 瞬时响应：网站的高性能架构常用操作系统响应时间表 1秒=1000毫秒=1000000微秒 性能测试指标 响应时间 并发数 吞吐量 性能计数器 性能计数器是描述服务器或操作系统的一些数据指标，包括System Load、对象与线程数、内存使用、CPU使用、磁盘与网络I/O等指标。System Load即系统负载，指当前整备CPU执行和等待被CPU执行的进程数目总和，是反映系统忙闲程度的重要指标。Linux系统中使用top命令查看。 性能测试方法 性能测试 负载测试 压力测试 稳定性测试 Web前端性能优化，一般Web前端是指网站业务逻辑之前的部分，包括浏览器加载、网站视图模型、图片服务、CDN服务等，主要优化手段有优化浏览器访问、使用反向代理、CDN等。 浏览器访问优化： 减少HTTP请求 使用浏览器缓存 启用压缩 CSS放在页面最上面、JavaScript放在页面最下面 减少Cookie传输 应用服务器性能优化，主要优化手段有缓存、集群、异步等。网站性能优化第一定律：优先考虑缓存优化性能。 分布式缓存 异步操作（消息队列具有很好的削峰作用） 使用集群 代码优化 不使用消息队列服务器 使用消息队列服务器 代码优化 多线程：解决线程安全主要手段是将对象设计成无状态对象、使用局部对象、并访问资源时使用锁。 资源复用：比如数据库连接、网络通信连接、线程、复杂对象等。编程角度资源复用主要有两种模式：单例和对象池。 数据结构 垃圾回收 第五章 网站的高可用架构分层后按模块分割的网站架构模型 应用服务器集群的Session管理 Session复制 Session绑定 利用Cookie记录Session Session服务器 高可用的服务 分级管理：核心应用和服务优先使用更好的硬件 超时设置 异步调用 服务降级：有两种手段，拒绝服务和关闭服务 幂等性设计：服务层保证服务重复调用和调用一次产生的结果相同，即服务具有幂等性(如转账操作) 高可用的数据有如下几方面的含义： 数据持久性：保证数据可持久存储 数据可访问性 数据一致性 CAP原理认为，一个提供数据服务的存储系统无法同时满足数据一致性(Consistency)、数据可用性(Availibility)、分区耐受性(Patition Tolerance,系统具有跨网络分区的伸缩性)这三个条件，如图所示： 第六章 永无止境：网站的伸缩性架构所谓网站的伸缩性是指不需要改变网站的软硬件设计,仅仅通过改变部署的服务器数量就可以扩大或缩小网站的服务处理能力。 负载均衡的基础技术： HTTP重定向负载均衡 DNS域名解析负载均衡 反向代理负载均衡 IP负载均衡 数据链路层负载均衡(LVS) 负载均衡算法： 轮询(Round Robin,RR) 加权轮询(Weighted Round Robin,WRR) 随机(Random) 最少连接(Least Connections) 源地址散列(Source Hashing) Memcached分布式缓存访问模型 分布式缓存的一致性Hash算法 使用虚拟节点的一致性Hash环：具体应用中，这个长度为2的32次方的一致性Hash环通常采用二叉查找树实现，这个二叉树的最右边叶子节点和最左边的叶子节点相连接，构成环。 计算机领域有句话：计算机的任何问题都可以通过增加一个虚拟层来解决，上图中的一台物理服务器对应的虚拟机服务器节点的数量经验值是150。 第七章 随需应变：网站的可扩展架构扩展性(Extensibility):指对现有系统影响最小的情况下，系统功能可持续扩展或提升的能力。表现在系统基础设施稳定不需要经常变更，应用之间较少依赖和耦合，对需求变更可以敏捷响应。它是系统架构设计层面的开闭原则(对扩展开放，对修改关闭)。 伸缩性(Scalability):指系统能够通过增加(减少)自身资源规模的方式增强(减少)自己计算处理事务的能力。 第八章 固若金汤：网站的安全架构]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet学习笔记]]></title>
    <url>%2F2016%2F09%2F10%2FServlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Servlet简介Servlet是什么？Java Servlet是运行在Web服务器或者应用服务器上的程序，他是作为来自Web浏览器或者其他HTTP客户端的请求和HTTP服务器上的数据或者应用程序之间的中间层。 Servlet任务 读取浏览器发送的显示数据 读取浏览器发送的隐式的HTTP请求数据 处理数据并生成结果 发送显式的数据到浏览器 发送隐式的HTTP响应到浏览器 Servlet包Java Servlet是运行在带有支持Java Servlet规范的解释器的web服务器上的Java类。 Servlet可以使用javax.servlet和javax.servlet.http包创建。 Servlet生命周期Servlet生命周期可以定义为从创建到销毁的整个过程，一下是Servlet遵循的过程： Servlet通过掉用init()方法进行初始化 Servlet调用service()方法来处理客户端的请求 Servlet通过调用destroy()方法终止 最后，Servlet是由JVM的垃圾回收器进行垃圾回收 init()方法init方法被设计成只调用一次。 service()方法service()方法是执行实际任务的主要方法。每次服务器收到一个Servlet请求时，服务器会产生一个新的线程并调用服务。service()方法检测后HTTP请求类型(GET、POST、PUT、DELETE等)，并在适当的时候调用doGet、doPost、doPut和doDelete等方法。 destroy()方法destroy方法只会调用一次，在Servlet生命周期结束时被调用。destroy()方法可以让Servlet关闭数据库连接、停止后台线程、把Cookie列表或点击计数器写入到磁盘，并执行其他类似的清理活动。 Get和Post方法HTTP规范定义 GET方法 The GET method means retrieve whatever information(in the form of an entity) is identified by the Request-URI. POST方法 The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line. 通过以上定义： GET方法用于获取资源 POST方法用于保存于更新资源 GET 请求的一些特点: GET 请求会有 cache GET 请求会保留在浏览历史中 GET 请求可以保存到书签 GET 请求不应用于处理敏感数据 GET 请求有长度限制 GET 请求应该只用于获取数据 POST 请求的一些特点: POST 不会有cache POST 请求不会出现在浏览器的浏览历史中 POST 请求不能保存到书签 POST 也是有长度限制的(不同的Web Server可能实现不同) 两者区别： GET方式： 采用URL跳转方式来请求，有长度限制 POST方式： 把请求参数显示到请求体中，没有长度限制]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java专项练习总结]]></title>
    <url>%2F2016%2F07%2F27%2FJava%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1、子类A继承父类B，A a = new A();执行先后顺序是： 父类Ｂ静态变量->父类Ｂ静态代码块->子类A静态变量->子类Ａ静态代码块->父类Ｂ非静态代码块->父类Ｂ构造函数->子类Ａ非静态代码块->子类Ａ构造函数 2、有如下一段代码，请选择其运行结果（） public class StringDemo&#123; private static final String MESSAGE="taobao"; public static void main(String []() args) &#123;String a ="tao"+"bao";String b="tao";String c="bao";System.out.println(a==MESSAGE);System.out.println((b+c)==MESSAGE); &#125;&#125; true false 3、在基本JAVA类型中，如果不明确指定，整数型的默认是什么类型？带小数的默认是什么类型？ int double 4、下面代码正确的是 public class Test&#123; public int x; public static void main(String args[]()) &#123; System. out. println("Value is" + x); &#125;&#125; 非静态变量不能够被静态方法引用 5、Jalsefalsetruetruefalseava程序中的类名称必须与存放该类的文件名相同。 错 解析：声明为public类型的类名必须与文件名相同，默认权限的可以不同并且内部类的类名一般与文件名不同。 6、以下代码的输出结果是？ public class B &#123;public static B t1 = new B();public static B t2 = new B();&#123;System.out.println("构造块");&#125;static&#123;System.out.println("静态块");&#125;public static void main(String[]() args)&#123;System.out.println("Main方法");B t = new B();&#125;&#125; 构造块 构造块 静态块 Main方法 构造块 解析：静态块，用static声明，JVM加载类时实行，仅执行一次。构造块，类中直接用{}定义，每一创建对象时执行。执行顺序优先级：静态块>main()>构造块>构造方法。题中的静态变量优先级最高，最先执行，因此先调用两次构造块。 7、下面代码的输出结果是？ public class Demo &#123;public static void main(String args[]()) &#123;String str1 = new String("hello");String str2 = new String("hello");String str3 = "hello";String str4 = "hello";String str5 = "he"+"llo";String str6 = "he";String str7 = "llo";System.out.println(str1==str2);System.out.println(str1==str3);System.out.println(str3==str4);System.out.println(str3=="hello");System.out.println(str4==(str6+str7));&#125;&#125; falsefalsetruetruefalse 解析：String str1 = new String(“hello”);这种方式创建的字符串，和正常创建对象一样，保存在堆区。 ​ String str3 = “hello”;这种方式创建的字符串，保存在字符串常量区。 8、BufferedReader的父类是一下哪个？ Reader 解析: 9、下面程序输出为： public class EqualsMethod&#123;public static void main(String[]() args)&#123;Integer n1 = new Integer(47);Integer n2 = new Integer(47);System.out.print(n1 == n2);System.out.print(",");System.out.println(n1 != n2);&#125;&#125; false,true 解析：当Integer n1 = 47；或者Integer n1 = Integer.valueOf(47);值介于-128127时，才作为基本类型相等。 10 、下面代码的输出结果是： public class test&#123;static&#123; int x=5;&#125;static int x,y;public static void main(String args[]())&#123; x--; myMethod( ); System.out.println(x+y+ ++x);&#125;public static void myMethod( )&#123; y=x++ + ++x; &#125;&#125; prints：3 解析：1、静态语句块中的x为局部变量，不影响静态变量x的值。2、x和y为静态变量，默认初始值为0，属于当前类。3、java中自增操作非原子性的，main方法中： 执行x–后x=-1 调用myMethod方法，x执行x++结果为-1，但x=0，++x结果为1，则y=0 x+y+ ++x先执行x+y，结果为1，执行++x结果为2，得到最终结果为3 11、下面代码的输出结果是： public class test3&#123;public static void main(String args[]())&#123;int a =1,b =1;int c1 = a+++b;System.out.println("a:"+a+"b:"+b+"c:"+c1);int c2 = a++ + ++b;System.out.println("a:"+a+"b:"+b+"c:"+c2);int c3 = a+++b;System.out.println("a:"+a+"b:"+b+"c:"+c3);//int c4 = a+++++b; 编译错误System.out.println("a:"+a+"b:"+b+"c:"+c3);int c5 = a+++b++;System.out.println("a:"+a+"b:"+b+"c:"+c5);&#125;&#125; a:2b:1c:2a:3b:2c:4a:4b:2c:5a:4b:2c:5a:5b:3c:6 12、下面代码的输出正确的是： byte b1=1,b2=2,b3,b6; final byte b4=4,b5=6; b6=b4+b5; b3=(b1+b2); System.out.println(b3+b6); 语句：b3=b1+b2编译出错 解析：被final修饰的变量是常量，这里b6=b4+b5可以看成是b6=10；在编译时已经变成b6=10了。而b1和b2是byte类型，java中进行计算时把他们提升为int类型，再进行计算，b1+b2计算后是int类型，赋值给b3，b3是byte类型，类型不匹配，因此编译不通过。 13、一下关于Java语言异常处理描述正确的有？ A、throw用于抛出异常 B、throws关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过throw抛出异常对象 解析：注意throws和throw方法的区别 14、抽象类和接口的区别？ 抽象类 特点: 1.抽象类中可以构造方法 2.抽象类中可以存在普通属性，方法，静态属性和方法。 3.抽象类中可以存在抽象方法。 4.如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。 5.抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。 接口 1.在接口中只有方法的声明，没有方法体。 2.在接口中只有常量，因为定义的变量，在编译的时候都会默认加上 public static final 3.在接口中的方法，永远都被public来修饰。 4.接口中没有构造方法，也不能实例化接口的对象。 5.接口可以实现多继承 6.接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法 7.则实现类定义为抽象类。 15、Java程序的种类有（） 内嵌于Web文件中，由浏览器查看的Applet 可独立运行的Application 服务器端的Servlet 16、下列哪些针对代码运行结果的描述是正确的？ class Car extends Vehicle&#123;public static void main (String[]() args)&#123;new Car(). run();&#125;private final void run()&#123;System. out. println ("Car");&#125;&#125;class Vehicle&#123;private final void run()&#123;System. out. println("Vehicle");&#125;&#125; Car 解析：因为Vehicle类中的run方法是private的，因此子类Car中可以定义run方法。 17、下面代码的输出结果是？ public class IfTest&#123;public static void main(string[]()args)&#123;int x=3;int y=1;if(x=y)system.out.println(“Not equal”);elsesystem.out.println(“Equal”); &#125;&#125; An error at line 5 causes compilation to fall. 解析：Java中if括号中的值是Boolean，而非整型。因此，结果中为整型会出现编译错误。 18、有关hashMap和hashTable的区别，说法正确的是？ A、HashMap和Hashtable都实现了Map接口 B、HashMap是非synchronized，而Hashtable是synchronized C、HashTable使用Enumeration，HashMap使用Iterator D、Hashtable直接使用对象的hashCode，HashMap重新计算hash值，而且用与代替求模 19、下面代码的输出结果？ package Wangyi;class Base&#123;public void method()&#123;System.out.println("Base");&#125; &#125;class Son extends Base&#123;public void method()&#123;System.out.println("Son");&#125; public void methodB()&#123;System.out.println("SonB");&#125;&#125;public class Test01&#123;public static void main(String[]() args)&#123;Base base = new Son();base.method();base.methodB();&#125;&#125; 编译不通过 解析：Base base = new Son();创建了一个Base类的对象，new一个派生类赋值给积累，而基类中不含methodB方法，因此编译不通过。 20、ServletConfig接口默认是哪里实现的？ GenericServlet 21、Servlet的生命周期可以分为初始化阶段，运行阶段和销毁阶段三个阶段，以下过程属于初始化阶段是（）。 A、加载Servlet类及.class对应的数据 B、创建serletRequest和servletResponse对象 C、创建ServletConfig对象 D、创建Servlet对象 ACD 22 、下面代码的输出是什么？ public class Base&#123;private String baseName = "base";public Base()&#123;callName();&#125; public void callName()&#123;System. out. println(baseName);&#125; static class Sub extends Base&#123;private String baseName = "sub";public void callName()&#123;System. out. println (baseName) ;&#125;&#125;public static void main(String[]() args)&#123;Base b = new Sub();&#125;&#125; null 解析：new Sub();在创建基类的过程中首先穿件基类对象，然后才能创建派生类，创建基类则默认调用Base()方法，在方法中调用callName()方法，由于派生类中存在此方法，则被调用的callName()方法是派生类中的方法，此时派生类还没有构造，所有变量baseName的值为null。]]></content>
      <categories>
        <category>专项练习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本排序算法]]></title>
    <url>%2F2016%2F06%2F06%2F%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简单介绍几种基础的排序算法及Java语言实现 冒泡排序 时间复杂度O(n^2) 从第一个元素开始两两比较，如果前者比后者大则交换连两个元素，直至到最后一个元素。一趟排序结果使数值最大的元素移至最后一个，经过n趟排序后，最终实现从小到大排序。 代码如下，需要注意的是注意输入待排序元素数组的有效性。 public class BubbleSort &#123; public int[] bubbleSort(int[] A, int n) &#123; if(A == null || A.length&lt;2)&#123; return A; &#125; int tempA = 0; for(int i=0;i&lt;n-1;i++)&#123; for(int j=0;j&lt;n-i-1;j++)&#123; if (A[j]&gt;A[j+1])&#123; tempA = A[j]; A[j] = A[j+1]; A[j+1] = tempA; &#125; &#125; &#125; return A; &#125;&#125; 选择排序 时间复杂度O(n^2) 在一趟把最小的的元素中找出来放在查找元素中的最前面的位置，下次查找从未排序的元素中进行查找。 public class SelectionSort &#123; public int[] selectionSort(int[] A, int n) &#123; if(A == null||A.length&lt;2)&#123; return A; &#125; for(int i=0;i&lt;n;i++)&#123; int min = i; for(int j=i+1;j&lt;n;j++)&#123; min = A[j]&lt;A[min]?j:min; &#125; int tempA = 0; if(min!=i)&#123; tempA = A[i]; A[i] = A[min]; A[min] = tempA; &#125; &#125; return A; &#125;&#125; 插入排序 时间复杂度O(n^2) 一组元素中从第一元素开始依次前1，2…n比较，插入到比它小的元素之前。 public class InsertionSort &#123; public int[] insertionSort(int[] A, int n) &#123; if(A == null||A.length&lt;2)&#123; return A; &#125; int tempA = 0; for(int i = 1;i &lt; n;i++)&#123; int insert = i; for(int j = i-1;j &gt;= 0;j--)&#123; if(A[insert]&lt;A[j])&#123; tempA = A[insert]; A[insert] = A[j]; A[j] = tempA; insert = j; &#125; else&#123; break; &#125; &#125; &#125; return A; &#125;&#125; 归并排序 时间复杂度O（n*logn） 首先，每个两个元素构成一个区间，然后区间内排序，再分别将每两个小区间合并为一个区间，再进行排序，最终完成所有元素的排序。 public class MergeSort &#123; private static int[] aux; public int[] mergeSort(int[] A, int n) &#123; aux = new int[n]; for(int sz=1;sz&lt;n;sz = sz+sz)&#123; for (int begin = 0;begin&lt;n-sz;begin=begin+sz+sz)&#123; merge(A,begin,begin+sz-1,Math.min(begin+sz+sz-1,n-1)); &#125; &#125; return A; &#125; public static void merge(int[] a, int begin, int mid, int end)&#123; int i = begin,j = mid+1; for(int k=begin;k&lt;=end;k++)&#123; aux[k] = a[k]; &#125; for(int k=begin;k&lt;=end;k++)&#123; if(i&gt;mid)&#123; a[k]=aux[j++];//先获取j的值再执行j+1 &#125; else if(j&gt;end)&#123; a[k]=aux[i++]; &#125; else if(aux[j]&lt;aux[i])&#123; a[k]=aux[j++]; &#125; else a[k]=aux[i++]; &#125; &#125;&#125; 快速排序 时间复杂度O（n*logn） 首先，在一组数中随机选择一个数N，小于等于N的所有数放在N的左边，大于的N的数放在N的右边。然后，对N的坐标和右边的数递归上述过程，直至全部数字有序。 public class QuickSort &#123; public int[] quickSort(int[] A, int n) &#123; sort(A,0,n-1); return A; &#125; private static int[] sort(int[] A,int lo,int hi)&#123; if (lo &lt; hi) &#123; //Util.printArray(A); int j = partition(A, lo, hi); sort(A, lo, j - 1); sort(A, j + 1, hi); &#125; return A; &#125; private static int partition(int[] A,int lo,int hi)&#123; int i = lo; int j = hi+1; int v = A[lo]; while(i&lt;hi&amp;&amp;j&gt;lo)&#123; while(v&gt;A[++i])&#123; if (i==hi) break; &#125; while(v&lt;A[--j])&#123; if (j==lo) break; &#125; if (i&gt;j) break; exch(A,i,j); &#125; exch(A,lo,j); return j; &#125; private static void exch(int[] A,int i,int j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125;&#125; 需要注意的是，在递归函数sort中，需要加入返回值数组A，否则出现栈溢出错误。另外，划分函数partition中，注意数组越界的问题。 堆排序 时间复杂度O（n*logn） 首先，根据数组中的N个元素建立大小为N的大根堆，堆顶是所有元素中最大的数。然后，将堆顶元素和堆中最后一个元素交换，脱离出堆的最后一个元素，作为有序部分保存下来。接下来把N-1的堆进行调整，获得倒数第二大的元素，保存下来。 public class HeapSort &#123; public int[] heapSort(int[] A, int n) &#123; int[] B = new int[n+1]; for(int p=0;p&lt;A.length;p++)&#123; B[p+1]=A[p]; &#125; for(int k=n/2;k&gt;=1;k--)&#123; sink(B,k,n); &#125; while(n&gt;1)&#123; exch(B,1,n--); sink(B,1,n); &#125; for(int q=0;q&lt;A.length;q++)&#123; A[q]=B[q+1]; &#125; return A; &#125; private void sink(int[] A,int k,int N)&#123; while(2*k&lt;=N) &#123; int j = 2*k; if(j&lt;N&amp;&amp;A[j]&lt;A[j+1]) j++; if(A[k]&gt;A[j]) break; exch(A, k, j); k=j; &#125; &#125; private void exch(int[] A,int i,int j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125;&#125; 希尔排序 时间复杂度O（n*logn） 希尔排序实际上是插入排序的改良算法。希尔排序的步长逐渐从大到小逐渐调整，例如：3，2，1。每一个元素按照步长，从后前比较调整。需要注意的是，步长最后都会变成1。希尔排序的关键是步长的选择。 public class ShellSort &#123; public int[] shellSort(int[] A, int n) &#123; int h = 1; while(h&lt;n) h = 3*h+1; while(h&gt;=1) &#123; for (int i = h; i &lt; n; i++) &#123; for (int j = i;j&gt;=h&amp;&amp;A[j]&lt;A[j-h];j-=h) exch(A,j,j-h); &#125; h = h/3; &#125; return A; &#125; private static void exch(int[] A,int i,int j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串的左旋转]]></title>
    <url>%2F2016%2F05%2F14%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B7%A6%E6%97%8B%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[​ 字符串的左旋转操作是把字符串的前面的若干字符串转移到字符串的尾部 题目​ 字符串的左旋转操作是把字符串的前面的若干字符串转移到字符串的尾部。请定义一个函数实现字符串的左旋转操作的功能。比如输入字符串“abcdefg”和数字2，该函数将返回左旋转2位得到的结果“cdefgab”。 解法思路一：暴力移位​ 分析题目发现，”abcdefg“左旋转2位后变成”cdefgab“过程中，cdefg向左移动了2位，ab可以看做向左移动2位后”溢出“。定义原字符串转化为数组arr，移位后的数组为res，则有如下关系：res[i]=arr[(i+n)%len]。遍历arr将原数组赋值到对应的res中。 ​ 此方法的时间复杂度为O(n)，空间复杂度为(n)。 public String LeftRotateString(String str, int n) &#123; char[] arr = str.toCharArray(); char[] res = str.toCharArray(); int len = arr.length; for (int i = 0; i &lt; len; i++) &#123; res[i] = arr[(i + n) % len]; &#125; str = String.valueOf(res); return str;&#125; 思路二：三步翻转​ 暴力移位方法中的空间复杂度为O(n)，但是实际上可以优化空间，在原数组中进行调整。三步翻转法可以实现题目中的要求，步骤如下： ​ 第一步，翻转第1位至第n位的字符。 ​ 第二步，翻转第n+1位至最后一位的字符。 ​ 第三步，翻转第1位至最后一位的字符。 ​ 此方法的时间复杂度O(n),空间复杂度O(1)。 public String LeftRotateString(String str, int n) &#123; if (n &lt; 0 || n &gt; str.length()) &#123; return ""; &#125; char[] arr = str.toCharArray(); reverse(arr, 0, n - 1); reverse(arr, n, str.length() - 1); reverse(arr, 0, str.length() - 1); return String.valueOf(arr); &#125;public void reverse(char[] arr, int left, int right) &#123; while (left &lt; right) &#123; char tmp = arr[left]; arr[left] = arr[right]; arr[right] = tmp; left++; right--; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客]]></title>
    <url>%2F2016%2F04%2F16%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[本文主要介绍Mac OS X环境下Hexo基本配置、Next主题配置和Github配置，最后针对使用过程中常见问题和解决方法进行补充说明。 正如官方网站介绍的，Hexo是快速、简洁且高效的博客框架。实际上Hexo确实是比较好用的，界面简洁实用而且还有很多第三方插件和主题，仅仅需要简单的配置就可以实现强大的功能。此外，官网提供的文档也比较详细，常用的功能一目了然。 基本配置安装环境Hexo是基于Node.js，需要对其进行安装，下载Node.js $ curl https://raw.github.com/creationix/nvm/master/install.sh | sh 下载完成后，重启终端执行下面命令进行安装，nvm是Node版本管理器 $ nvm install 4 由于Mac OS X自带git，所以不需要额外安装 Hexo安装使用npm安装Hexo（Node Package Manager，Node包管理器） $ npm install -g hexo-cli 如果本地部署服务器的话需要安装hexo-server，否则hexo server命令无效 $ npm install hexo-server --save Hexo使用Hexo需要创建一个文件夹保存工程文件，例如 $ hexo init &lt;文件夹名&gt; $ cd &lt;文件夹名&gt; $ npm install 文件名下面所在的文件目录如下 . ├── _config.yml 整个站点配置信息 ├── package.json 应用程序信息 ├── scaffolds 文章模板文件夹 ├── source 资源文件夹 | ├── _drafts | └── _posts └── themes 主题文件夹 创建文章如果没有layout的话，使用网站配置文件中默认的布局，如果标题中含有空格的话用引号括起来，文章默认保存在/source/_post文件夹下面。 $ hexo new [layout] &lt;title&gt; 生成静态文件,下面两条命令均可 $ hexo generate $ hexo g 启动服务器，下面两条命令均可 $ hexo server $ hexo s 部署网站，下面两条命令均可,如果部署到Github上，参考下面Github和SSH配置 $ hexo deploy $ hexo d Next主题配置安装next $ cd your-hexo-site $ git clone https://github.com/iissnan/hexo-theme-next themes/next 启动主题，在网站配置文件中修改theme字段 theme：next Github和SSH配置部署到github上首先需要安装hero-deployer-git $ npm install hexo-deployer-git --save 修改站点配置文件，注意属性和值之间有空格 deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 相关问题代码显示Next主题中代码如果通过上下三个点号显示代码行数，显示效果 $ curl https://raw.github.com/creationix/nvm/master/install.sh | sh 如果通过空四个空格，效果则变成 $ curl https://raw.github.com/creationix/nvm/master/install.sh | sh 标题显示文章各级标题需要在#之后与标题加一个空格，否则无法显示 segmentation fault博客文件测试如果过大的情况下，如果执行 hexo g等命令是会提示segmention fault的错误。 参考资料https://hexo.io/ http://theme-next.iissnan.com/]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS X常用命令及操作]]></title>
    <url>%2F2016%2F04%2F14%2FUnix-Like%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Mac OS X常用命令及快捷键操作 日常命令 立即关机sudo shutdown -h now 立即睡眠sudo shutdown -s now 显示隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool true 隐藏隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool false 删除文件夹rm -rf 文件夹名 移动文件mv 源文件 目标文件夹 文件/文件夹重命名 mv 原名称 新名称 复制文件夹 cp -r 原文夹 目标路径 访问相对路径cd ../文件名 访问刚才的目录cd - 命令含义 echo 显示、打印出 Bash快捷键 光标移动至行首 ctrl+a 关闭移动至行尾 ctrl+e 杀死当前进程 ctrl+c 退出当前Shell ctrl+d 清屏 ctrl+l ​]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术博客]]></title>
    <url>%2F2016%2F04%2F14%2F%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[技术博客不断更新中 团队阿里技术沙龙 美团技术博客 IBM developerworks 腾讯 AlloyTeam 个人王垠 daimajia Trinea JacksonTian cloudwu michaelliao laruence]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vimium - 黑客的浏览器]]></title>
    <url>%2F2016%2F04%2F13%2FVimium-%E9%BB%91%E5%AE%A2%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Vimium是一款Chrome插件，它通过Vim编辑器的灵魂提供了基于键盘方式的操作网页。 键盘绑定分别将ctrl+x，meta+x和alt+x修改为&lt;c-x&gt;,&lt;m-x&gt;和&lt;a-x&gt;。下一节介绍如何自定义这些绑定。一旦安装Vimium后，可以通过打?显示下面的键盘绑定列表。操作当前页面： ？ 显示可用键列表的帮助对话框 h 向左滚动 j 向右滚动 k 向上滚动 l 向右滚动 gg 滚动到页面顶部 G 滚动页面底部 d 向下滚动一半页面（down） u 向上滚动一半页面（up） f 在当前标签打开一个链接 F 在新标签打开一个链接 r 重载（reload） gs 查看源代码 i 进入插入模式 — 敲击Esc退出之前所有命令将被忽略 yy 复制当前url到剪帖板 yf 复制一个链接到剪贴板 gf 向前到下一个页面 gF 聚焦到主页面/顶级页面 操作一个新网页： o 打开并进入URL，书签或历史记录 O 在新标签打开并计入URL，历史记录 b 打开书签（bookmark） B 在新标签打开书签 运用查找： / 进入查找模式 - 输入查找或者Esc退出 n 向前查询匹配项 N 向后查询匹配项 备注：n和N使用方法是先使用/进行查找，然后按回车，最后使用n或者N进行查找 操作历史记录： H 在历史记录中回退 L 在历史记录中前进 操作标签： J，gT 进入左侧标签 K，gt 进入右侧标签 g0 进入第一个标签 g$ 进入最后一个标签 t 创建标签 yt 复制当前标签 x 关闭当前标签 X 恢复关闭标签 T 在打开标签中搜索 &lt;a-p&gt; 插入/移除当前标签 自定义键盘映射用户可以在“自定义键盘映射”选项页面重新映射默认键盘绑定。 Vimium开源项目链接]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Vimium</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacNotes(一)：Mac远程访问Windows]]></title>
    <url>%2F2016%2F03%2F19%2FMacNotes(%E4%B8%80)%EF%BC%9AMac%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEWindows%2F</url>
    <content type="text"><![CDATA[虽然平时主力是Mac环境，但是偶尔还是用Windows比较舒服，比如Office等等。但是来回切换两种环境简直太糟心了。原来的解决方案是有一台MacBook，一台Windows主机和一台显示器，两者都通过切换显示器来切换环境，但是因为不想多弄一个键盘，导致切换系统时需要把键盘鼠标的转换线来回插拔。昨天无意间发现一个及其方便的解决方案：Mac远程访问Windows。虽然它俩之间距离还不到一米，但是图像确实还是需要在路由器走一圈，下面介绍一下解决方案，通过Microsoft Remote Desk远程访问Winows。 软件： Microsoft Remote Desktop 主要步骤： 需要下载Microsoft Remote Desktop，但是不知道为什么APPStore中国地区不提供下载，需要注册美国苹果账号。 Windows开启远程访问，查询本机ip地址，记录IP。 Microsoft Remote Desktop建立链接，输入IP地址，用户名和密码。 点击Start即可连接 ​Mac和Windows时间的文件传输也是一个重要的问题。使用一段时间发现，虽然Windows和Mac之间的网址什么的复制粘贴没有问题，但是文件之间的复制就行了。 OneDrive虽然能够处理体积的较小的文件，但是传递文件速度还是很慢，大文件根本就不能够考虑了。本来打算在Windows下建一个FTP，这样就能够实现Mac访问Windows的文件，但是无奈至今不知道出现了什么问题，仍然无法在Windows下面建立FTP。下面介绍一种简单的Mac获取Windows文件的方法。 在Microsoft Remote Desktop中找到Redirection 点击+，输入文件夹的路径和名称 在Windows中会显示相应的网络磁盘 直接将文件复制到磁盘中即可，Mac相应的文件中就会显示相应的文件]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
</search>
